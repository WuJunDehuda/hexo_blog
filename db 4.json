{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Unix环境高级编程开篇-apue-h配置.md","hash":"b16855e21bc269b0000f77cac11c6b1103b77736","modified":1660223747126},{"_id":"source/.DS_Store","hash":"a7990f7ac6cc4321dac83f5b0d8cdc38ba9b33c4","modified":1659752337374},{"_id":"source/_posts/.DS_Store","hash":"593d2c8ff61b88436f1396098fdb1a01206f0954","modified":1660205268059},{"_id":"source/_posts/Ubuntu安装docker并用Portainer管理.md","hash":"4b508df68d31d1ad3f31f19097b6102b11af1261","modified":1660217197176},{"_id":"source/_posts/Linux终端命令行神器screen.md","hash":"842175d776dced3654e2e94edaa961568c6be117","modified":1660211510883},{"_id":"source/_posts/Unix环境高级编程第三章-文件I-O.md","hash":"d69f356ea7c86c010750e369cfd9a936978f26de","modified":1660309069255},{"_id":"source/_posts/Unix环境高级编程第八章-进程控制.md","hash":"3c24835463bd5a5012ac45390f4c33e3c48a50bf","modified":1660273988653},{"_id":"source/_posts/基于Docker的FRP内网穿透部署.md","hash":"9952936e21204ee344ba12aef63d071b4d4ba467","modified":1660223655866},{"_id":"source/categories/index.md","hash":"09c714e360c6f89c249dbe84a5352b0673255400","modified":1658653264652},{"_id":"source/tags/index.md","hash":"6e709da1e62754410c91a0e73e70a56e7f5c740d","modified":1660201869736},{"_id":"source/_data/link.yml","hash":"f464ea29535e0ac2f73723ca95522ba8c7996138","modified":1660314928096},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1658652691154},{"_id":"source/link/index.md","hash":"608135e77bbe6182f1af5534c17a69ba9a03defc","modified":1660315403064},{"_id":"themes/butterfly/_config.yml","hash":"26a7fa8c79b3732318e751875aff79975abe3775","modified":1659753293604},{"_id":"themes/butterfly/package.json","hash":"3bcb70e12282156703626e238e3719611c34c3b7","modified":1659753199611},{"_id":"themes/butterfly/plugins.yml","hash":"0194c4fb88a6be30d983a83ac22072bb4d799c9a","modified":1659753199611},{"_id":"themes/butterfly/languages/default.yml","hash":"1e37a3695d50e3e61d7c36e58a6dac872a4a56cd","modified":1659753199602},{"_id":"themes/butterfly/languages/en.yml","hash":"d1bb560698eb8b0079495b7b18b44facb610f9fd","modified":1659753199602},{"_id":"themes/butterfly/.DS_Store","hash":"e5d8fb673b400f393225a56af8b7dcfbd76bda00","modified":1659754900284},{"_id":"themes/butterfly/.github/stale.yml","hash":"5e8ea535424e8112439135d21afc5262c0bc0b39","modified":1659753199602},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1659753199603},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1659753199611},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"947f794e862bb2813e36887f777bdb760f70a322","modified":1659753199603},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"28b6f0c39155651d747eb595e0a283bc97be2e09","modified":1659753199602},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1659753199603},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1659753199611},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1659753199602},{"_id":"themes/butterfly/README.md","hash":"cde88743f77bad1b463aa78049398b19f878090e","modified":1659753199602},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1659753199602},{"_id":"themes/butterfly/README_CN.md","hash":"01b4feffb432293223f540921ce2cde748b2d2fe","modified":1659753199602},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"67e4f5a66d4b8cabadbaad0410628364ee75e0ae","modified":1659753199601},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1659753199611},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1659753199603},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1659753199611},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"594a977ebe8d97e60fa3d7cb40fc260ded4d8a58","modified":1659753199603},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1659753199603},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1659753199605},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"de8e618ec03295561c667a49e1c383213b856f6f","modified":1659753199603},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1659753199611},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"699d0d2cff233628752956c4434125c8203f7d63","modified":1659753199606},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8d39473ed112d113674a0f689f63fae06c72abd2","modified":1659753199606},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"acfe765fb2c607bff7198630dbfa53a888c36357","modified":1659753199611},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"a557280a25f63f4312afad63fc3303ec74165557","modified":1659753199604},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1659753199612},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"a3d1f417965ca20253c36f9e93429f3df6268856","modified":1659753199611},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1659753199601},{"_id":"themes/butterfly/scripts/events/init.js","hash":"b4940a5c73d3a5cd8bb5883e3041ecdd905a74e0","modified":1659753199612},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"21379ed2dccb69c43b893895c9d56238c11e5f43","modified":1659753199612},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"3cfc46c749e2fd7ae9c2a17206238ed0e0e17e7d","modified":1659753199612},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1659753199612},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"763dab5c83f50c1c62fffc9a9dfedea29bb4e629","modified":1659753199612},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"b4cd617c619d1a0df93603721a6fa1317526174b","modified":1659753199612},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1659753199612},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"ee3e70098eb0849497d50b75e18cf4a27c397d52","modified":1659753199612},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1659753199612},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1659753199601},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1659753199613},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1659753199612},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"f79c99f6c5b626c272dc2bed2b0250d6b91bb28a","modified":1659753199613},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"d368a8830e506c8b5eb6512b709ec8db354d5ea1","modified":1659753199612},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1659753199613},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1659753199613},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1659753199613},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1659753199613},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1659753199613},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1659753199613},{"_id":"themes/butterfly/source/.DS_Store","hash":"e8f91c77eb4f8c2e4c47683a2cc9039b07d20db3","modified":1659754900283},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1659753199613},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1659753199617},{"_id":"themes/butterfly/source/css/var.styl","hash":"4890a40366d6443f8b8942a4e9a6dce9fe3494f5","modified":1659753199617},{"_id":"themes/butterfly/source/js/main.js","hash":"73d2624ed465e4cfb1ebb00b2c8a24f5fc29bb21","modified":1659753199618},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1659753199617},{"_id":"themes/butterfly/source/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1659753199618},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1659753199617},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1659753199618},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"15530d9ac59c576d79af75dd687efe71e8d261b0","modified":1659753199603},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"8f41fa9732ea654a10f6e666d9c782c7e27e5ea6","modified":1659753199603},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1659753199617},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"65a23b5170204e55b813ce13a79d799b66b7382c","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1659753199603},{"_id":"themes/butterfly/source/img/.DS_Store","hash":"562715fa4c5ce721e51892be9f3f46fbb6c481ec","modified":1659757257437},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"78a3abd90bb3c18cd773d3d5abac3541e7f415e5","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"aa175e2254704335f4da09175e59ef2375ca7d03","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1659753199603},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1659753199605},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1659753199605},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1659753199605},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"fed069baa9b383f57db32bb631115071d29bdc60","modified":1659753199605},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"6311eda08e4515281c51bd49f43902a51832383c","modified":1659753199605},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1659753199605},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1659753199605},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1659753199606},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"8c2524e843adfce00b16e31ee355f14ce9ffb8ba","modified":1659753199604},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"0d10532648d0335254f21a3b7d8676cb96ea8eba","modified":1659753199605},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"6d6474ef186c18d9b4f334e1f735eadd6699effa","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"bae2f32ac96cebef600c1e37eaa8467c9a7e5d92","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"e37468e63db2a0ac09b65d21b7de3e62425bb455","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1659753199611},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1659753199611},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1659753199611},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"7fb096656c8a6c21a4b6a5100885b1081d6021ed","modified":1659753199611},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"714f19e7d66df84938bd1b82b33d5667abe1f147","modified":1659753199613},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"644d520fe80cc82058467708ab82ccad313b0c27","modified":1659753199613},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1659753199613},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1659753199614},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1659753199611},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"a92984f566c97bb4179f34be79240af1552c6f17","modified":1659753199615},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"a0010d833ed30211601c1e0bbbc68e85b77428c6","modified":1659753199614},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1659753199614},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"69f8e9414526dfda3af9a71c8e528fdd0ecbbfe5","modified":1659753199615},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1659753199614},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"d97c1722ce0fcc319f1f90ec2d51f9d746748e2b","modified":1659753199614},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"26be2afa9d4e7016cf3c42a6cd166f01e8e4ad5c","modified":1659753199614},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ef21990de28bd75dcd0f88b8d616e1a7a137502f","modified":1659753199615},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"15056fba0bd5a45ea8dc97eb557f6929ff16797a","modified":1659753199615},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1659753199605},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1659753199615},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1659753199604},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1659753199615},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1659753199615},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1659753199615},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6f4b4ede52305bce9b22c8c897dcbde8af6e2ce4","modified":1659753199615},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1659753199615},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1659753199616},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a58d35d698885f1034dedbe99f7dbc1a801412c6","modified":1659753199616},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1659753199616},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bd88ee30ebf8ca2e7b4d3a034c317fd61733921f","modified":1659753199615},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"8314e9749eb1ae40c4bae9735b7a6638b2d6876a","modified":1659753199615},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1659753199616},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1659753199616},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"8c90483d461e09cb06e91b16d8bb7b3205b0a40c","modified":1659753199616},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"a310e48f826a4cacc55d8e68f43806e5085554f6","modified":1659753199616},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1659753199616},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1659753199616},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1659753199616},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1659753199616},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1659753199617},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1659753199617},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"51e45625929d57c9df3ba9090af99b9b7bb9a15b","modified":1659753199616},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"25e58a7a8bda4b73d0a0e551643ca01b09ccd7e5","modified":1659753199616},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1659753199617},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1659753199617},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1659753199606},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1659753199606},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"2be601477e1b81eee90a00c14ce5c8761d19a332","modified":1659753199606},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1659753199606},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"98ef20f8a3b10c1692f9b2b3c06033d2da8a8eae","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"8ec24c1939895ac0db2b2e8700bc9307b4ceb53c","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"22e2ef30fe5eb1db7566e89943c74ece029b2a8e","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"58406a7a3bf45815769f652bf3ef81e57dcd07eb","modified":1659753199606},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"190b1cca42c7f73c50f62f07d0751449941bff3f","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"2e26af16d359ba362fa611575d7f547848057c0c","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"2d8fc3fb8f9aec61400acf3c94070bd8539058f8","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"591ef23c583690bd74af0cafb09af64ba5bd8151","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"e9bdf80d6796afc04eb809dbbe780d97f22c7fcd","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"e18fbd88d8942e53e771f29b26209ab735c5c567","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"a737046e730eb7264606ba0536218964044492f9","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1659753199608},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"39d61cbe0c1e937f83ba3b147afaa29b4de2f87d","modified":1659753199616},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"15462d1ed04651ad3b430c682842ac400f6f9b47","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"f4dc7d02c8192979404ae9e134c5048d3d0a76e2","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"8e33aca36a4d3ae9e041ba05ced8eff56ae38f77","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1659753199608},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"8ca02f97bfa93fff9cce5b8eb8feb234e7beeb98","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"5f648086a33a32d169a2f8d8c549c08aa02f67db","modified":1659753199607},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"dd0bc119029b62dce5dc965d5de7377e438fa29a","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"ab167c00da4506f591b96f0591bf5bd214a26d4b","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"e8245d0b4933129bb1c485d8de11a9e52e676348","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1659753199609},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1659753199618},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1659753199610},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"9feb248552667c53ce1b19bc7a295215f8c77008","modified":1659753199618},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"233907dd7f5b5f33412701d2ccffbc0bbae8707b","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"f61d63724ea5c5f352568b3a16bde023affefbe5","modified":1659753199610},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"178c9cdcc4ce5a006885b24ce4a3d624e4734899","modified":1659753199609},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d19e1c2c0a50f0e4547d71a17b9be88e8152f17c","modified":1659753199609},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1659753199614},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1659753199614},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1659753199614},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1659753199614},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1659753199614},{"_id":"themes/butterfly/source/img/avatar.png","hash":"de50354e3472d9509eae90510f3900dc3df207b6","modified":1649867120016},{"_id":"public/atom.xml","hash":"b28bea5f0cf56ab57d332a3f9a835ff9f08d1cb6","modified":1660316474601},{"_id":"public/search.xml","hash":"3d9e2d7c7dc73a6c0f8364ebd9b7a8e373d29e86","modified":1660316474601},{"_id":"public/sitemap.xml","hash":"802811bf8113b6f302872d7a56a4cb5d1ee58d4c","modified":1660321279621},{"_id":"public/sitemap.txt","hash":"7a80a30dd9d48e9f911fd50a2f790593125004e9","modified":1660321279621},{"_id":"public/categories/index.html","hash":"1c514a77096d0c202e3bd1e2beffa19d77eebe07","modified":1660321431080},{"_id":"public/tags/index.html","hash":"8c33c1964c1a9b2c808e04e8233522ee552fea1e","modified":1660321431080},{"_id":"public/2022/08/11/Ubuntu安装docker并用Portainer管理/index.html","hash":"fa840500dfcb9949940e4aa865206a8624bae375","modified":1660321279621},{"_id":"public/2022/08/11/基于Docker的FRP内网穿透部署/index.html","hash":"3234ee37787bafe5a75e4173d71e938c937cf4c2","modified":1660321279621},{"_id":"public/2022/08/12/Unix环境高级编程第八章-进程控制/index.html","hash":"18fdea04c864d4eb10cbb68be22c440257ffaaea","modified":1660321279621},{"_id":"public/link/index.html","hash":"90b45adff1dee9a9ecd3f88dd25ef827d9274798","modified":1660321431080},{"_id":"public/2022/08/11/Unix环境高级编程第三章-文件I-O/index.html","hash":"9498d51875b37a0454cbb6789b35934be35c5d7b","modified":1660321279621},{"_id":"public/2022/08/11/Unix环境高级编程开篇-apue-h配置/index.html","hash":"b7a9bf37741656d85e93b32ba926d02369892478","modified":1660321279621},{"_id":"public/2022/08/06/Linux终端命令行神器screen/index.html","hash":"3f5b4c2c2b03718f7dd6eb0f2e24b775ca97d956","modified":1660321279621},{"_id":"public/2022/07/24/hello-world/index.html","hash":"0cbaa8fefe9854b9d6682ad3ff2c5fba1327181e","modified":1660321279621},{"_id":"public/index.html","hash":"04db03a795f6f42c8ce30b0b7e7d6435b0936c53","modified":1660321431080},{"_id":"public/categories/Linux学习/index.html","hash":"0802928e2de591c67d56b2ad639e473de1da1ab5","modified":1660321431080},{"_id":"public/categories/Linux工具/index.html","hash":"fb3d034e6ccc8090840a0776280cc3f0d554a456","modified":1660321431080},{"_id":"public/categories/折腾一台小服务器/index.html","hash":"f3918be990f3ea9bf9b49fad85e2638041591ee3","modified":1660321431080},{"_id":"public/tags/Linux/index.html","hash":"2a9e64205d8b9313cbf318e4dbaf7e1abe52753c","modified":1660321431080},{"_id":"public/tags/Docker/index.html","hash":"c47c238ea5be15e84c7d889140d19e3324bfa7d7","modified":1660321431080},{"_id":"public/archives/index.html","hash":"5babf11d921e1e9aacb655a110a4ab2b001f4d43","modified":1660321431080},{"_id":"public/archives/2022/index.html","hash":"43abddef1741410dc19c53bd381fdd98f88037ad","modified":1660321431080},{"_id":"public/archives/2022/07/index.html","hash":"eeb7b85006423f854f66e831d28cb31873d7c8d6","modified":1660321431080},{"_id":"public/archives/2022/08/index.html","hash":"91db4055214557dde5928f708ea30f2175090bc8","modified":1660321431080},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1660316474601},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1660316474601},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1660316474601},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660316474601},{"_id":"public/js/search/algolia.js","hash":"9feb248552667c53ce1b19bc7a295215f8c77008","modified":1660316474601},{"_id":"public/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1660316474601},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1660316474601},{"_id":"public/js/main.js","hash":"73d2624ed465e4cfb1ebb00b2c8a24f5fc29bb21","modified":1660316474601},{"_id":"public/css/index.css","hash":"0e65903757975877c8ef4c87b486b19ac89d653e","modified":1660316474601},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1660316474601},{"_id":"public/img/avatar.png","hash":"de50354e3472d9509eae90510f3900dc3df207b6","modified":1660316474601},{"_id":"source/about/index.md","hash":"a663bfb76727e33541d177c07995808dd96a2b91","modified":1660320112911},{"_id":"source/messageboard/index.md","hash":"a5bb6d68be10c0976636c9b248aa3cc4ef820cb6","modified":1660321348037},{"_id":"public/about/index.html","hash":"ab856d930c619a33ceede672dc46a10d50a04aed","modified":1660321431080},{"_id":"public/messageboard/index.html","hash":"a051312c33d860ae227b57b625373499ad1bfdb0","modified":1660321431080}],"Category":[{"name":"Linux学习","_id":"cl6qlk73b00034lz2hofzbbal"},{"name":"Linux工具","_id":"cl6qlk73h000a4lz261l762j6"},{"name":"折腾一台小服务器","_id":"cl6qlk73k000m4lz2h72vbioi"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"分类","date":"2022-07-24T09:00:08.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类 \ndate: 2022-07-24 17:00:08\ntype: \"categories\"\n---\n","updated":"2022-07-24T09:01:04.652Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl6qlk73700004lz2bx2q7m3t","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","excerpt":"","more":""},{"title":"标签","date":"2022-07-24T08:59:03.000Z","type":"tags","top_img":"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/hexo.jpg","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-07-24 16:59:03\ntype: \"tags\"\ntop_img: https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/hexo.jpg\n---\n","updated":"2022-08-11T07:11:09.736Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl6qlk73a00024lz26sqn654m","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","excerpt":"","more":""},{"title":"link","date":"2022-08-12T14:42:33.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2022-08-12 22:42:33\ntype: \"link\"\n---\n","updated":"2022-08-12T14:43:23.064Z","path":"link/index.html","comments":1,"layout":"page","_id":"cl6qlk73c00054lz20w5z58dj","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","excerpt":"","more":""},{"title":"messageboard","date":"2022-08-12T16:18:58.000Z","type":"留言板","_content":"","source":"messageboard/index.md","raw":"---\ntitle: messageboard\ndate: 2022-08-13 00:18:58\ntype: \"留言板\"\n---\n","updated":"2022-08-12T16:22:28.037Z","path":"messageboard/index.html","_id":"cl6qof6ov0000u3z2697k9573","comments":1,"layout":"page","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","excerpt":"","more":""},{"title":"about","date":"2022-08-12T16:01:52.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-08-13 00:01:52\n---\n","updated":"2022-08-12T16:01:52.911Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl6qof6ox0001u3z267d326vr","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","excerpt":"","more":""}],"Post":[{"title":"Unix环境高级编程开篇-apue.h配置","date":"2022-08-11T01:38:43.000Z","cover":"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161416.png","_content":"\n书中大部分代码都#include \"apue\"头文件，本文件记录了配置apue头文件的过程。\n\n## 一、下载该头文件\n\n- 使用命令行下载`wget http://www.apuebook.com/src.3e.tar.gz`\n- 到官网手动下载 [传送门](http://www.apuebook.com/apue3e.html)\n\n## 二、解压\n\n```\ntar -zxvf src.3e.tar.gz\n```\n\n## 三、复制两个文件\n\n```cpp\n/home/Downloads/apu.3e/include    /* apue.h */\n/home/Downloads/apu.3e/lib       /* error.c */\n##将两个文件拷贝到默认的c语言库中\ncp ./include/apue.h ./lib/error.c /usr/include\n```\n\n## 四、修改文件内容\n\n#### 在apue.h 头文件的最后一行前添加一行代码：\n\n```\n#include \"erro.c\"\n```\n\n最后效果如下\n\n```cpp\n#include \"error.c\"\n#endif  /* _APUE_H */\n```\n\n## 五、结语\n\n最后便可使用apue头文件，不需要再次编译apue.3e\n","source":"_posts/Unix环境高级编程开篇-apue-h配置.md","raw":"---\ntitle: Unix环境高级编程开篇-apue.h配置\ndate: 2022-08-11 09:38:43\ntags:\n  - Linux\ncategories: Linux学习\ncover: https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161416.png\n---\n\n书中大部分代码都#include \"apue\"头文件，本文件记录了配置apue头文件的过程。\n\n## 一、下载该头文件\n\n- 使用命令行下载`wget http://www.apuebook.com/src.3e.tar.gz`\n- 到官网手动下载 [传送门](http://www.apuebook.com/apue3e.html)\n\n## 二、解压\n\n```\ntar -zxvf src.3e.tar.gz\n```\n\n## 三、复制两个文件\n\n```cpp\n/home/Downloads/apu.3e/include    /* apue.h */\n/home/Downloads/apu.3e/lib       /* error.c */\n##将两个文件拷贝到默认的c语言库中\ncp ./include/apue.h ./lib/error.c /usr/include\n```\n\n## 四、修改文件内容\n\n#### 在apue.h 头文件的最后一行前添加一行代码：\n\n```\n#include \"erro.c\"\n```\n\n最后效果如下\n\n```cpp\n#include \"error.c\"\n#endif  /* _APUE_H */\n```\n\n## 五、结语\n\n最后便可使用apue头文件，不需要再次编译apue.3e\n","slug":"Unix环境高级编程开篇-apue-h配置","published":1,"updated":"2022-08-11T13:15:47.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6qlk73900014lz2a7pc6nfo","content":"<p>书中大部分代码都#include “apue”头文件，本文件记录了配置apue头文件的过程。</p>\n<h2 id=\"一、下载该头文件\"><a href=\"#一、下载该头文件\" class=\"headerlink\" title=\"一、下载该头文件\"></a>一、下载该头文件</h2><ul>\n<li>使用命令行下载<code>wget http://www.apuebook.com/src.3e.tar.gz</code></li>\n<li>到官网手动下载 <a href=\"http://www.apuebook.com/apue3e.html\">传送门</a></li>\n</ul>\n<h2 id=\"二、解压\"><a href=\"#二、解压\" class=\"headerlink\" title=\"二、解压\"></a>二、解压</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf src.3e.tar.gz</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、复制两个文件\"><a href=\"#三、复制两个文件\" class=\"headerlink\" title=\"三、复制两个文件\"></a>三、复制两个文件</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/Downloads/apu<span class=\"number\">.3</span>e/include    <span class=\"comment\">/* apue.h */</span></span><br><span class=\"line\">/home/Downloads/apu<span class=\"number\">.3</span>e/lib       <span class=\"comment\">/* error.c */</span></span><br><span class=\"line\">##将两个文件拷贝到默认的c语言库中</span><br><span class=\"line\">cp ./include/apue.h ./lib/error.c /usr/include</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、修改文件内容\"><a href=\"#四、修改文件内容\" class=\"headerlink\" title=\"四、修改文件内容\"></a>四、修改文件内容</h2><h4 id=\"在apue-h-头文件的最后一行前添加一行代码：\"><a href=\"#在apue-h-头文件的最后一行前添加一行代码：\" class=\"headerlink\" title=\"在apue.h 头文件的最后一行前添加一行代码：\"></a>在apue.h 头文件的最后一行前添加一行代码：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;erro.c&quot;</span><br></pre></td></tr></table></figure>\n\n<p>最后效果如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;error.c&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span>  <span class=\"comment\">/* _APUE_H */</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、结语\"><a href=\"#五、结语\" class=\"headerlink\" title=\"五、结语\"></a>五、结语</h2><p>最后便可使用apue头文件，不需要再次编译apue.3e</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p>书中大部分代码都#include “apue”头文件，本文件记录了配置apue头文件的过程。</p>\n<h2 id=\"一、下载该头文件\"><a href=\"#一、下载该头文件\" class=\"headerlink\" title=\"一、下载该头文件\"></a>一、下载该头文件</h2><ul>\n<li>使用命令行下载<code>wget http://www.apuebook.com/src.3e.tar.gz</code></li>\n<li>到官网手动下载 <a href=\"http://www.apuebook.com/apue3e.html\">传送门</a></li>\n</ul>\n<h2 id=\"二、解压\"><a href=\"#二、解压\" class=\"headerlink\" title=\"二、解压\"></a>二、解压</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf src.3e.tar.gz</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、复制两个文件\"><a href=\"#三、复制两个文件\" class=\"headerlink\" title=\"三、复制两个文件\"></a>三、复制两个文件</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/home/Downloads/apu<span class=\"number\">.3</span>e/include    <span class=\"comment\">/* apue.h */</span></span><br><span class=\"line\">/home/Downloads/apu<span class=\"number\">.3</span>e/lib       <span class=\"comment\">/* error.c */</span></span><br><span class=\"line\">##将两个文件拷贝到默认的c语言库中</span><br><span class=\"line\">cp ./include/apue.h ./lib/error.c /usr/include</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、修改文件内容\"><a href=\"#四、修改文件内容\" class=\"headerlink\" title=\"四、修改文件内容\"></a>四、修改文件内容</h2><h4 id=\"在apue-h-头文件的最后一行前添加一行代码：\"><a href=\"#在apue-h-头文件的最后一行前添加一行代码：\" class=\"headerlink\" title=\"在apue.h 头文件的最后一行前添加一行代码：\"></a>在apue.h 头文件的最后一行前添加一行代码：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;erro.c&quot;</span><br></pre></td></tr></table></figure>\n\n<p>最后效果如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;error.c&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span>  <span class=\"comment\">/* _APUE_H */</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、结语\"><a href=\"#五、结语\" class=\"headerlink\" title=\"五、结语\"></a>五、结语</h2><p>最后便可使用apue头文件，不需要再次编译apue.3e</p>\n"},{"title":"Linux终端命令行神器screen","date":"2022-08-06T01:24:06.000Z","cover":"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161528.png","_content":"screen的功能\nscreen的功能大体有三个：\n● 会话恢复：只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。\n● 多窗口：在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。\n● 会话共享：Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。\n这三个功能，其实互相交织，组成screen功能繁多的命令集。\n`sudo apt install screen`\nscreen命令集\nscreen，通常的命令格式为：\n`screen [-opts] [cmd [args]]`\n通常情况下，使用一下基础命令即可，高阶命令过多，比较难记。\n注意：\n● 命令区分大小写\n状态介绍\n通常情况下，screen创建的虚拟终端，有两个工作模式：\n● Attached：表示当前screen正在作为主终端使用，为活跃状态。\n● Detached：表示当前screen正在后台使用，为非激发状态。\n通常情况下，不需要关注上面的状态。\n基础命令\n这里列举一些我认为常用的screen命令，使用以下命令基本满足日常使用。\n● 查询screen提示：\n`screen -help`\n● 终端列表\n`screen -ls`\n● 新建终端\n\n```\n#新建一个叫test的虚拟终端\n#注意S为大写\n\nscreen -S test\nscreen -R test\n```\n\n","source":"_posts/Linux终端命令行神器screen.md","raw":"---\ntitle: Linux终端命令行神器screen\ndate: 2022-08-06 09:24:06\ntags: \n  - Linux\ncategories: Linux工具\ncover: https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161528.png\n---\nscreen的功能\nscreen的功能大体有三个：\n● 会话恢复：只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。\n● 多窗口：在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。\n● 会话共享：Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。\n这三个功能，其实互相交织，组成screen功能繁多的命令集。\n`sudo apt install screen`\nscreen命令集\nscreen，通常的命令格式为：\n`screen [-opts] [cmd [args]]`\n通常情况下，使用一下基础命令即可，高阶命令过多，比较难记。\n注意：\n● 命令区分大小写\n状态介绍\n通常情况下，screen创建的虚拟终端，有两个工作模式：\n● Attached：表示当前screen正在作为主终端使用，为活跃状态。\n● Detached：表示当前screen正在后台使用，为非激发状态。\n通常情况下，不需要关注上面的状态。\n基础命令\n这里列举一些我认为常用的screen命令，使用以下命令基本满足日常使用。\n● 查询screen提示：\n`screen -help`\n● 终端列表\n`screen -ls`\n● 新建终端\n\n```\n#新建一个叫test的虚拟终端\n#注意S为大写\n\nscreen -S test\nscreen -R test\n```\n\n","slug":"Linux终端命令行神器screen","published":1,"updated":"2022-08-11T09:51:50.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6qlk73g00084lz2grq27x5k","content":"<p>screen的功能<br>screen的功能大体有三个：<br>● 会话恢复：只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。<br>● 多窗口：在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。<br>● 会话共享：Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。<br>这三个功能，其实互相交织，组成screen功能繁多的命令集。<br><code>sudo apt install screen</code><br>screen命令集<br>screen，通常的命令格式为：<br><code>screen [-opts] [cmd [args]]</code><br>通常情况下，使用一下基础命令即可，高阶命令过多，比较难记。<br>注意：<br>● 命令区分大小写<br>状态介绍<br>通常情况下，screen创建的虚拟终端，有两个工作模式：<br>● Attached：表示当前screen正在作为主终端使用，为活跃状态。<br>● Detached：表示当前screen正在后台使用，为非激发状态。<br>通常情况下，不需要关注上面的状态。<br>基础命令<br>这里列举一些我认为常用的screen命令，使用以下命令基本满足日常使用。<br>● 查询screen提示：<br><code>screen -help</code><br>● 终端列表<br><code>screen -ls</code><br>● 新建终端</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#新建一个叫test的虚拟终端</span><br><span class=\"line\">#注意S为大写</span><br><span class=\"line\"></span><br><span class=\"line\">screen -S test</span><br><span class=\"line\">screen -R test</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p>screen的功能<br>screen的功能大体有三个：<br>● 会话恢复：只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。<br>● 多窗口：在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。<br>● 会话共享：Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。<br>这三个功能，其实互相交织，组成screen功能繁多的命令集。<br><code>sudo apt install screen</code><br>screen命令集<br>screen，通常的命令格式为：<br><code>screen [-opts] [cmd [args]]</code><br>通常情况下，使用一下基础命令即可，高阶命令过多，比较难记。<br>注意：<br>● 命令区分大小写<br>状态介绍<br>通常情况下，screen创建的虚拟终端，有两个工作模式：<br>● Attached：表示当前screen正在作为主终端使用，为活跃状态。<br>● Detached：表示当前screen正在后台使用，为非激发状态。<br>通常情况下，不需要关注上面的状态。<br>基础命令<br>这里列举一些我认为常用的screen命令，使用以下命令基本满足日常使用。<br>● 查询screen提示：<br><code>screen -help</code><br>● 终端列表<br><code>screen -ls</code><br>● 新建终端</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#新建一个叫test的虚拟终端</span><br><span class=\"line\">#注意S为大写</span><br><span class=\"line\"></span><br><span class=\"line\">screen -S test</span><br><span class=\"line\">screen -R test</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Ubuntu安装docker并用Portainer管理","date":"2022-08-11T08:07:00.000Z","cover":"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161127.png","_content":"\n## 一、安装docker\n\n更新apt包索引\n\n```cpp\nsudo apt-get update\n```\n\n安装 apt 依赖包，用于通过HTTPS来获取仓库\n\n```cpp\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n```\n\n添加 Docker 的官方 GPG 密钥\n\n```cpp\ncurl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。\n\n```cpp\nsudo apt-key fingerprint 0EBFCD88\n   \npub   rsa4096 2017-02-22 [SCEA]\n      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid           [ unknown] Docker Release (CE deb) <docker@docker.com>\nsub   rsa4096 2017-02-22 [S]\n```\n\n使用以下指令设置稳定版仓库\n\n```cpp\nsudo add-apt-repository \\\n   \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \\\n  $(lsb_release -cs) \\\n  stable\"\n```\n\n安装最新版本的 Docker Engine-Community 和 containerd\n\n```cpp\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n\n测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功\n\n```cpp\nsudo docker run hello-world\n\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete                                                                                                                                  Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f\nStatus: Downloaded newer image for hello-world:latest\n\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n\n## 二、安装Portainer\n\n创建 Portainer Server 存储数据库的卷\n\n```cpp\nsudo docker volume create portainer_data\n```\n\n下载并安装 Portainer Server 容器\n\n```cpp\nsudo docker run -d -p 8000:8000 -p 9443:9443 --name portainer \\\n    --restart=always \\ \n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v portainer_data:/data \n    \\portainer/portainer-ce:latest\n```\n\n查看 Docker 容器状态（NAMES 标签出现 portainer/portainer-ce 则成功运行）\n\n```cpp\nsudo docker ps\n```\n\n**使用 Ubuntu 自带的火狐浏览器访问（**https://127.0.0.1:9443/**）****或使用局域网内另一台计算机/手机的浏览器访问（https://服务器的IP:9443/）**\n\n**对 Portainer 初始设置**设置用户名及密码（8位字符或数字），点击 Get Started，载入后点击 local 即可\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660205149604-7fd72f5c-890f-42e8-af7d-fb69782fed86.png)\n","source":"_posts/Ubuntu安装docker并用Portainer管理.md","raw":"---\ntitle: Ubuntu安装docker并用Portainer管理\ndate: 2022-08-11 16:07:00\ntags: \n  - Linux\n  - Docker\ncategories: Linux工具\ncover: https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161127.png\n---\n\n## 一、安装docker\n\n更新apt包索引\n\n```cpp\nsudo apt-get update\n```\n\n安装 apt 依赖包，用于通过HTTPS来获取仓库\n\n```cpp\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n```\n\n添加 Docker 的官方 GPG 密钥\n\n```cpp\ncurl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。\n\n```cpp\nsudo apt-key fingerprint 0EBFCD88\n   \npub   rsa4096 2017-02-22 [SCEA]\n      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid           [ unknown] Docker Release (CE deb) <docker@docker.com>\nsub   rsa4096 2017-02-22 [S]\n```\n\n使用以下指令设置稳定版仓库\n\n```cpp\nsudo add-apt-repository \\\n   \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \\\n  $(lsb_release -cs) \\\n  stable\"\n```\n\n安装最新版本的 Docker Engine-Community 和 containerd\n\n```cpp\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n\n测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功\n\n```cpp\nsudo docker run hello-world\n\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n1b930d010525: Pull complete                                                                                                                                  Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f\nStatus: Downloaded newer image for hello-world:latest\n\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n\n## 二、安装Portainer\n\n创建 Portainer Server 存储数据库的卷\n\n```cpp\nsudo docker volume create portainer_data\n```\n\n下载并安装 Portainer Server 容器\n\n```cpp\nsudo docker run -d -p 8000:8000 -p 9443:9443 --name portainer \\\n    --restart=always \\ \n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v portainer_data:/data \n    \\portainer/portainer-ce:latest\n```\n\n查看 Docker 容器状态（NAMES 标签出现 portainer/portainer-ce 则成功运行）\n\n```cpp\nsudo docker ps\n```\n\n**使用 Ubuntu 自带的火狐浏览器访问（**https://127.0.0.1:9443/**）****或使用局域网内另一台计算机/手机的浏览器访问（https://服务器的IP:9443/）**\n\n**对 Portainer 初始设置**设置用户名及密码（8位字符或数字），点击 Get Started，载入后点击 local 即可\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660205149604-7fd72f5c-890f-42e8-af7d-fb69782fed86.png)\n","slug":"Ubuntu安装docker并用Portainer管理","published":1,"updated":"2022-08-11T11:26:37.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6qlk73g00094lz27486h3ij","content":"<h2 id=\"一、安装docker\"><a href=\"#一、安装docker\" class=\"headerlink\" title=\"一、安装docker\"></a>一、安装docker</h2><p>更新apt包索引</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n\n<p>安装 apt 依赖包，用于通过HTTPS来获取仓库</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install \\</span><br><span class=\"line\">    apt-transport-https \\</span><br><span class=\"line\">    ca-certificates \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    gnupg-agent \\</span><br><span class=\"line\">    software-properties-common</span><br></pre></td></tr></table></figure>\n\n<p>添加 Docker 的官方 GPG 密钥</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https:<span class=\"comment\">//mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br></pre></td></tr></table></figure>\n\n<p>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-key fingerprint <span class=\"number\">0</span>EBFCD88</span><br><span class=\"line\">   </span><br><span class=\"line\">pub   rsa4096 <span class=\"number\">2017</span><span class=\"number\">-02</span><span class=\"number\">-22</span> [SCEA]</span><br><span class=\"line\">      <span class=\"number\">9</span>DC8 <span class=\"number\">5822</span> <span class=\"number\">9F</span>C7 DD38 <span class=\"number\">854</span>A  E2D8 <span class=\"number\">8</span>D81 <span class=\"number\">803</span>C <span class=\"number\">0</span>EBF CD88</span><br><span class=\"line\">uid           [ unknown] <span class=\"function\">Docker <span class=\"title\">Release</span> <span class=\"params\">(CE deb)</span> &lt;docker@docker.com&gt;</span></span><br><span class=\"line\"><span class=\"function\">sub   rsa4096 2017-02-22 [S]</span></span><br></pre></td></tr></table></figure>\n\n<p>使用以下指令设置稳定版仓库</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository \\</span><br><span class=\"line\">   <span class=\"string\">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \\</span></span><br><span class=\"line\"><span class=\"string\">  $(lsb_release -cs) \\</span></span><br><span class=\"line\"><span class=\"string\">  stable&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>安装最新版本的 Docker Engine-Community 和 containerd</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n\n<p>测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run hello-world</span><br><span class=\"line\"></span><br><span class=\"line\">Unable to find image <span class=\"string\">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class=\"line\">latest: Pulling from library/hello-world</span><br><span class=\"line\"><span class=\"number\">1b</span>930d010525: Pull complete                                                                                                                                  Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> hello-world:latest</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Hello from Docker!</span><br><span class=\"line\">This message shows that your installation appears to be working correctly.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">To generate <span class=\"keyword\">this</span> message, Docker took the following steps:</span><br><span class=\"line\"> <span class=\"number\">1.</span> The Docker client contacted the Docker daemon.</span><br><span class=\"line\"> <span class=\"number\">2.</span> The Docker daemon pulled the <span class=\"string\">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class=\"line\">    (amd64)</span><br><span class=\"line\"> <span class=\"number\">3.</span> The Docker daemon created a <span class=\"keyword\">new</span> container from that image which runs the</span><br><span class=\"line\">    executable that produces the output you are currently reading.</span><br><span class=\"line\"> <span class=\"number\">4.</span> The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class=\"line\">    to your terminal.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">To <span class=\"keyword\">try</span> something more ambitious, you can run an Ubuntu container with:</span><br><span class=\"line\"> $ docker run -it ubuntu bash</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Share images, automate workflows, <span class=\"keyword\">and</span> more with a free Docker ID:</span><br><span class=\"line\"> https:<span class=\"comment\">//hub.docker.com/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">For more examples <span class=\"keyword\">and</span> ideas, visit:</span><br><span class=\"line\"> https:<span class=\"comment\">//docs.docker.com/get-started/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、安装Portainer\"><a href=\"#二、安装Portainer\" class=\"headerlink\" title=\"二、安装Portainer\"></a>二、安装Portainer</h2><p>创建 Portainer Server 存储数据库的卷</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker volume create portainer_data</span><br></pre></td></tr></table></figure>\n\n<p>下载并安装 Portainer Server 容器</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -d -p <span class=\"number\">8000</span>:<span class=\"number\">8000</span> -p <span class=\"number\">9443</span>:<span class=\"number\">9443</span> --name portainer \\</span><br><span class=\"line\">    --restart=always \\ </span><br><span class=\"line\">    -v /var/run/docker.sock:/var/run/docker.sock \\</span><br><span class=\"line\">    -v portainer_data:/data </span><br><span class=\"line\">    \\portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure>\n\n<p>查看 Docker 容器状态（NAMES 标签出现 portainer&#x2F;portainer-ce 则成功运行）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker ps</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用 Ubuntu 自带的火狐浏览器访问（</strong><a href=\"https://127.0.0.1:9443/**%EF%BC%89****%E6%88%96%E4%BD%BF%E7%94%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%89%8B%E6%9C%BA%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%EF%BC%88https://%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84IP:9443/%EF%BC%89\">https://127.0.0.1:9443/**）****或使用局域网内另一台计算机/手机的浏览器访问（https://服务器的IP:9443/）</a>**</p>\n<p><strong>对 Portainer 初始设置</strong>设置用户名及密码（8位字符或数字），点击 Get Started，载入后点击 local 即可</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660205149604-7fd72f5c-890f-42e8-af7d-fb69782fed86.png\" alt=\"img\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"一、安装docker\"><a href=\"#一、安装docker\" class=\"headerlink\" title=\"一、安装docker\"></a>一、安装docker</h2><p>更新apt包索引</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n\n<p>安装 apt 依赖包，用于通过HTTPS来获取仓库</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install \\</span><br><span class=\"line\">    apt-transport-https \\</span><br><span class=\"line\">    ca-certificates \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    gnupg-agent \\</span><br><span class=\"line\">    software-properties-common</span><br></pre></td></tr></table></figure>\n\n<p>添加 Docker 的官方 GPG 密钥</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https:<span class=\"comment\">//mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span></span><br></pre></td></tr></table></figure>\n\n<p>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-key fingerprint <span class=\"number\">0</span>EBFCD88</span><br><span class=\"line\">   </span><br><span class=\"line\">pub   rsa4096 <span class=\"number\">2017</span><span class=\"number\">-02</span><span class=\"number\">-22</span> [SCEA]</span><br><span class=\"line\">      <span class=\"number\">9</span>DC8 <span class=\"number\">5822</span> <span class=\"number\">9F</span>C7 DD38 <span class=\"number\">854</span>A  E2D8 <span class=\"number\">8</span>D81 <span class=\"number\">803</span>C <span class=\"number\">0</span>EBF CD88</span><br><span class=\"line\">uid           [ unknown] <span class=\"function\">Docker <span class=\"title\">Release</span> <span class=\"params\">(CE deb)</span> &lt;docker@docker.com&gt;</span></span><br><span class=\"line\"><span class=\"function\">sub   rsa4096 2017-02-22 [S]</span></span><br></pre></td></tr></table></figure>\n\n<p>使用以下指令设置稳定版仓库</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository \\</span><br><span class=\"line\">   <span class=\"string\">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \\</span></span><br><span class=\"line\"><span class=\"string\">  $(lsb_release -cs) \\</span></span><br><span class=\"line\"><span class=\"string\">  stable&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>安装最新版本的 Docker Engine-Community 和 containerd</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n\n<p>测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run hello-world</span><br><span class=\"line\"></span><br><span class=\"line\">Unable to find image <span class=\"string\">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class=\"line\">latest: Pulling from library/hello-world</span><br><span class=\"line\"><span class=\"number\">1b</span>930d010525: Pull complete                                                                                                                                  Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> hello-world:latest</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Hello from Docker!</span><br><span class=\"line\">This message shows that your installation appears to be working correctly.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">To generate <span class=\"keyword\">this</span> message, Docker took the following steps:</span><br><span class=\"line\"> <span class=\"number\">1.</span> The Docker client contacted the Docker daemon.</span><br><span class=\"line\"> <span class=\"number\">2.</span> The Docker daemon pulled the <span class=\"string\">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class=\"line\">    (amd64)</span><br><span class=\"line\"> <span class=\"number\">3.</span> The Docker daemon created a <span class=\"keyword\">new</span> container from that image which runs the</span><br><span class=\"line\">    executable that produces the output you are currently reading.</span><br><span class=\"line\"> <span class=\"number\">4.</span> The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class=\"line\">    to your terminal.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">To <span class=\"keyword\">try</span> something more ambitious, you can run an Ubuntu container with:</span><br><span class=\"line\"> $ docker run -it ubuntu bash</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Share images, automate workflows, <span class=\"keyword\">and</span> more with a free Docker ID:</span><br><span class=\"line\"> https:<span class=\"comment\">//hub.docker.com/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">For more examples <span class=\"keyword\">and</span> ideas, visit:</span><br><span class=\"line\"> https:<span class=\"comment\">//docs.docker.com/get-started/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、安装Portainer\"><a href=\"#二、安装Portainer\" class=\"headerlink\" title=\"二、安装Portainer\"></a>二、安装Portainer</h2><p>创建 Portainer Server 存储数据库的卷</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker volume create portainer_data</span><br></pre></td></tr></table></figure>\n\n<p>下载并安装 Portainer Server 容器</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -d -p <span class=\"number\">8000</span>:<span class=\"number\">8000</span> -p <span class=\"number\">9443</span>:<span class=\"number\">9443</span> --name portainer \\</span><br><span class=\"line\">    --restart=always \\ </span><br><span class=\"line\">    -v /var/run/docker.sock:/var/run/docker.sock \\</span><br><span class=\"line\">    -v portainer_data:/data </span><br><span class=\"line\">    \\portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure>\n\n<p>查看 Docker 容器状态（NAMES 标签出现 portainer&#x2F;portainer-ce 则成功运行）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker ps</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用 Ubuntu 自带的火狐浏览器访问（</strong><a href=\"https://127.0.0.1:9443/**%EF%BC%89****%E6%88%96%E4%BD%BF%E7%94%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%89%8B%E6%9C%BA%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%EF%BC%88https://%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84IP:9443/%EF%BC%89\">https://127.0.0.1:9443/**）****或使用局域网内另一台计算机/手机的浏览器访问（https://服务器的IP:9443/）</a>**</p>\n<p><strong>对 Portainer 初始设置</strong>设置用户名及密码（8位字符或数字），点击 Get Started，载入后点击 local 即可</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660205149604-7fd72f5c-890f-42e8-af7d-fb69782fed86.png\" alt=\"img\"></p>\n"},{"title":"Unix环境高级编程第八章-进程控制","date":"2022-08-12T03:12:21.000Z","cover":"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161416.png","_content":"\n## 8.2 进程标识\n\n每个进程都有一个非负整型表示唯一的进程ID。\n\n```cpp\n// 下列函数返回进程的一些其他标识符\n#include<unistd.h>\n\npid_t getpid(void);\t\t\t//返回值：调用进程的进程ID\n\npid_t getppid(void);\t\t//返回值：调用进程的父进程ID\n\nupid_t getpid(void);\t\t//返回值：调用进程的实际用户ID\n\ngpid_t getpid(void);\t\t//返回值：调用进程的实际组ID\n```\n\n## 8.3 函数fork\n\n```cpp\n// 一个现有的进程可以调用fork函数创建一个新进程\n#include<unistd.h>\n\npid_t fork(void);\n//返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1\n```\n\n子进程是父进程的副本，但并不共享存储空间。父进程和子进程共享正文段。\n\n很多时候子进程并不执行父进程的完全副本，而是使用了写时复制（COW）技术，由父进程与子进程共享数据区域，由内核将他们的权限改变为只读，当需要修改时再复制一份副本。\n\n#### 8.3.c\n\n```cpp\n$ gcc 8.3.c -lapue\n$ ./a.out \na write to stdout\nbefore fork\npid = 11998, glob = 7, var = 89\npid = 11997, glob = 6, var = 88\n$ ./a.out > temp.out\n$ cat temp.out \na write to stdout\nbefore fork\npid = 12021, glob = 7, var = 89\nbefore fork\npid = 12020, glob = 6, var = 88\n```\n\n当输出到终端时stdout是行缓冲，输出到文件时是全缓冲。\n\n全缓冲。输入或输出缓冲区被填满，会进行实际 I/O 操作。其他情况，如强制刷新、进程结束也会进行实际I/O操作。\n\n```cpp\nif (write(STDOUT_FILENO, buf, sizeof(buf)) != sizeof(buf))\n```\n\nsizeof(buf)-1忽略了buf末尾的null，因此 \"a write to stdout\\n\" 留在了缓冲区中。\n\nbuf直接写入标准输出，不受缓冲区影响。\n\nprintf(\"before fork\\n\")在输出到文件时未flush缓冲区，在fork的过程中复制了缓冲区，因此输出了两次。\n\n#### 文件共享\n\n父进程和子进程每个相同的打开描述符\n\n- 共享一个文件表项\n- 共享同一个文件偏移量\n\nfork的两个常见用法：\n\n- 父进程与子进程执行不同的代码段\n- 一个进程要执行一个不同的程序（fork后立即调用exec）\n\n## 8.4 函数vfork\n\nvfork用于创造并执行一个新程序。\n\n#### 8.4.c\n\n```cpp\n$ gcc 8.4.c\n$ ./a.out\nbefore vfork\npid = 22413, glob = 7, car = 89\n```\n\nvfork与fork的区别在于：\n\n- vfork 会保证子进程在父进程之前运行，直到子进程触发了 exec 或者 exit 。\n- vfork 不会将父进程的地址空间完全复制过来，在子进程调用 exec 或者 exit 之前，它在父进程的空间中运行。\n\n## 8.5 函数exit\n\n如7.3所述，进程有5种正常及3种异常终止方式。\n\n我们希望终止进程能够通知父进程它是如何终止的，实现这一点的方式是将其退出状态作为参数传递给函数。\n\n若父进程在子进程之前终止，则子进程会被init进程收养。\n\n## 8.6 函数wait和waitpid\n\n当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。\n\n当一个进程调用wait或waitpid可能发生：\n\n- 如果所有子进程都还在运行，则阻塞\n- 如果一个子进程已经终止，等待父进程获取其终止状态，则取得状态返回。\n- 如果没有任何子进程则立即出差返回\n\n```cpp\n#inlcude<sys/wait.h>\n\npid_t wait(int *statloc)\n    \npid_t waitpid(pid_t pid,int *statloc,int options)\n    \n//两个函数返回值：若成功，则返回进程ID；若出错，则返回0或-1\n```\n\n若statloc不为空，则终止状态便存放在该单元中，可以使用<sys/wait.h>中的宏来查看。\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660272991111-28e0a4d0-70b8-47be-9b6d-16398b01776f.png)\n\n#### 8.6.c\n\n```cpp\n$ gcc 8.6.c\n$ ./a.out\nnormal termination, exit status = 7\nabnormal termination, signal number = 6  (core file generated)\nabnormal termination, signal number = 8  (core file generated)\n```\n\n#### 对于waitpid中pid参数的解释\n\n- pid==1 等待任一子进程\n- pid>0 等待进程ID与pid相等的子进程\n- pid==0 等待进程组ID等于调用进程组pid的任一子进程\n","source":"_posts/Unix环境高级编程第八章-进程控制.md","raw":"---\ntitle: Unix环境高级编程第八章-进程控制\ndate: 2022-08-12 11:12:21\ntags:\n  - Linux\ncategories: Linux学习\ncover: https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161416.png\n---\n\n## 8.2 进程标识\n\n每个进程都有一个非负整型表示唯一的进程ID。\n\n```cpp\n// 下列函数返回进程的一些其他标识符\n#include<unistd.h>\n\npid_t getpid(void);\t\t\t//返回值：调用进程的进程ID\n\npid_t getppid(void);\t\t//返回值：调用进程的父进程ID\n\nupid_t getpid(void);\t\t//返回值：调用进程的实际用户ID\n\ngpid_t getpid(void);\t\t//返回值：调用进程的实际组ID\n```\n\n## 8.3 函数fork\n\n```cpp\n// 一个现有的进程可以调用fork函数创建一个新进程\n#include<unistd.h>\n\npid_t fork(void);\n//返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1\n```\n\n子进程是父进程的副本，但并不共享存储空间。父进程和子进程共享正文段。\n\n很多时候子进程并不执行父进程的完全副本，而是使用了写时复制（COW）技术，由父进程与子进程共享数据区域，由内核将他们的权限改变为只读，当需要修改时再复制一份副本。\n\n#### 8.3.c\n\n```cpp\n$ gcc 8.3.c -lapue\n$ ./a.out \na write to stdout\nbefore fork\npid = 11998, glob = 7, var = 89\npid = 11997, glob = 6, var = 88\n$ ./a.out > temp.out\n$ cat temp.out \na write to stdout\nbefore fork\npid = 12021, glob = 7, var = 89\nbefore fork\npid = 12020, glob = 6, var = 88\n```\n\n当输出到终端时stdout是行缓冲，输出到文件时是全缓冲。\n\n全缓冲。输入或输出缓冲区被填满，会进行实际 I/O 操作。其他情况，如强制刷新、进程结束也会进行实际I/O操作。\n\n```cpp\nif (write(STDOUT_FILENO, buf, sizeof(buf)) != sizeof(buf))\n```\n\nsizeof(buf)-1忽略了buf末尾的null，因此 \"a write to stdout\\n\" 留在了缓冲区中。\n\nbuf直接写入标准输出，不受缓冲区影响。\n\nprintf(\"before fork\\n\")在输出到文件时未flush缓冲区，在fork的过程中复制了缓冲区，因此输出了两次。\n\n#### 文件共享\n\n父进程和子进程每个相同的打开描述符\n\n- 共享一个文件表项\n- 共享同一个文件偏移量\n\nfork的两个常见用法：\n\n- 父进程与子进程执行不同的代码段\n- 一个进程要执行一个不同的程序（fork后立即调用exec）\n\n## 8.4 函数vfork\n\nvfork用于创造并执行一个新程序。\n\n#### 8.4.c\n\n```cpp\n$ gcc 8.4.c\n$ ./a.out\nbefore vfork\npid = 22413, glob = 7, car = 89\n```\n\nvfork与fork的区别在于：\n\n- vfork 会保证子进程在父进程之前运行，直到子进程触发了 exec 或者 exit 。\n- vfork 不会将父进程的地址空间完全复制过来，在子进程调用 exec 或者 exit 之前，它在父进程的空间中运行。\n\n## 8.5 函数exit\n\n如7.3所述，进程有5种正常及3种异常终止方式。\n\n我们希望终止进程能够通知父进程它是如何终止的，实现这一点的方式是将其退出状态作为参数传递给函数。\n\n若父进程在子进程之前终止，则子进程会被init进程收养。\n\n## 8.6 函数wait和waitpid\n\n当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。\n\n当一个进程调用wait或waitpid可能发生：\n\n- 如果所有子进程都还在运行，则阻塞\n- 如果一个子进程已经终止，等待父进程获取其终止状态，则取得状态返回。\n- 如果没有任何子进程则立即出差返回\n\n```cpp\n#inlcude<sys/wait.h>\n\npid_t wait(int *statloc)\n    \npid_t waitpid(pid_t pid,int *statloc,int options)\n    \n//两个函数返回值：若成功，则返回进程ID；若出错，则返回0或-1\n```\n\n若statloc不为空，则终止状态便存放在该单元中，可以使用<sys/wait.h>中的宏来查看。\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660272991111-28e0a4d0-70b8-47be-9b6d-16398b01776f.png)\n\n#### 8.6.c\n\n```cpp\n$ gcc 8.6.c\n$ ./a.out\nnormal termination, exit status = 7\nabnormal termination, signal number = 6  (core file generated)\nabnormal termination, signal number = 8  (core file generated)\n```\n\n#### 对于waitpid中pid参数的解释\n\n- pid==1 等待任一子进程\n- pid>0 等待进程ID与pid相等的子进程\n- pid==0 等待进程组ID等于调用进程组pid的任一子进程\n","slug":"Unix环境高级编程第八章-进程控制","published":1,"updated":"2022-08-12T03:13:08.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6qlk73h000c4lz2eecb07kt","content":"<h2 id=\"8-2-进程标识\"><a href=\"#8-2-进程标识\" class=\"headerlink\" title=\"8.2 进程标识\"></a>8.2 进程标识</h2><p>每个进程都有一个非负整型表示唯一的进程ID。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下列函数返回进程的一些其他标识符</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">getpid</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;\t\t\t<span class=\"comment\">//返回值：调用进程的进程ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">getppid</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;\t\t<span class=\"comment\">//返回值：调用进程的父进程ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">upid_t</span> <span class=\"title\">getpid</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;\t\t<span class=\"comment\">//返回值：调用进程的实际用户ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">gpid_t</span> <span class=\"title\">getpid</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;\t\t<span class=\"comment\">//返回值：调用进程的实际组ID</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-3-函数fork\"><a href=\"#8-3-函数fork\" class=\"headerlink\" title=\"8.3 函数fork\"></a>8.3 函数fork</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个现有的进程可以调用fork函数创建一个新进程</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<p>子进程是父进程的副本，但并不共享存储空间。父进程和子进程共享正文段。</p>\n<p>很多时候子进程并不执行父进程的完全副本，而是使用了写时复制（COW）技术，由父进程与子进程共享数据区域，由内核将他们的权限改变为只读，当需要修改时再复制一份副本。</p>\n<h4 id=\"8-3-c\"><a href=\"#8-3-c\" class=\"headerlink\" title=\"8.3.c\"></a>8.3.c</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc <span class=\"number\">8.3</span>.c -lapue</span><br><span class=\"line\">$ ./a.out </span><br><span class=\"line\">a write to stdout</span><br><span class=\"line\">before fork</span><br><span class=\"line\">pid = <span class=\"number\">11998</span>, glob = <span class=\"number\">7</span>, var = <span class=\"number\">89</span></span><br><span class=\"line\">pid = <span class=\"number\">11997</span>, glob = <span class=\"number\">6</span>, var = <span class=\"number\">88</span></span><br><span class=\"line\">$ ./a.out &gt; temp.out</span><br><span class=\"line\">$ cat temp.out </span><br><span class=\"line\">a write to stdout</span><br><span class=\"line\">before fork</span><br><span class=\"line\">pid = <span class=\"number\">12021</span>, glob = <span class=\"number\">7</span>, var = <span class=\"number\">89</span></span><br><span class=\"line\">before fork</span><br><span class=\"line\">pid = <span class=\"number\">12020</span>, glob = <span class=\"number\">6</span>, var = <span class=\"number\">88</span></span><br></pre></td></tr></table></figure>\n\n<p>当输出到终端时stdout是行缓冲，输出到文件时是全缓冲。</p>\n<p>全缓冲。输入或输出缓冲区被填满，会进行实际 I&#x2F;O 操作。其他情况，如强制刷新、进程结束也会进行实际I&#x2F;O操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">write</span>(STDOUT_FILENO, buf, <span class=\"built_in\">sizeof</span>(buf)) != <span class=\"built_in\">sizeof</span>(buf))</span><br></pre></td></tr></table></figure>\n\n<p>sizeof(buf)-1忽略了buf末尾的null，因此 “a write to stdout\\n” 留在了缓冲区中。</p>\n<p>buf直接写入标准输出，不受缓冲区影响。</p>\n<p>printf(“before fork\\n”)在输出到文件时未flush缓冲区，在fork的过程中复制了缓冲区，因此输出了两次。</p>\n<h4 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h4><p>父进程和子进程每个相同的打开描述符</p>\n<ul>\n<li>共享一个文件表项</li>\n<li>共享同一个文件偏移量</li>\n</ul>\n<p>fork的两个常见用法：</p>\n<ul>\n<li>父进程与子进程执行不同的代码段</li>\n<li>一个进程要执行一个不同的程序（fork后立即调用exec）</li>\n</ul>\n<h2 id=\"8-4-函数vfork\"><a href=\"#8-4-函数vfork\" class=\"headerlink\" title=\"8.4 函数vfork\"></a>8.4 函数vfork</h2><p>vfork用于创造并执行一个新程序。</p>\n<h4 id=\"8-4-c\"><a href=\"#8-4-c\" class=\"headerlink\" title=\"8.4.c\"></a>8.4.c</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc <span class=\"number\">8.4</span>.c</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">before vfork</span><br><span class=\"line\">pid = <span class=\"number\">22413</span>, glob = <span class=\"number\">7</span>, car = <span class=\"number\">89</span></span><br></pre></td></tr></table></figure>\n\n<p>vfork与fork的区别在于：</p>\n<ul>\n<li>vfork 会保证子进程在父进程之前运行，直到子进程触发了 exec 或者 exit 。</li>\n<li>vfork 不会将父进程的地址空间完全复制过来，在子进程调用 exec 或者 exit 之前，它在父进程的空间中运行。</li>\n</ul>\n<h2 id=\"8-5-函数exit\"><a href=\"#8-5-函数exit\" class=\"headerlink\" title=\"8.5 函数exit\"></a>8.5 函数exit</h2><p>如7.3所述，进程有5种正常及3种异常终止方式。</p>\n<p>我们希望终止进程能够通知父进程它是如何终止的，实现这一点的方式是将其退出状态作为参数传递给函数。</p>\n<p>若父进程在子进程之前终止，则子进程会被init进程收养。</p>\n<h2 id=\"8-6-函数wait和waitpid\"><a href=\"#8-6-函数wait和waitpid\" class=\"headerlink\" title=\"8.6 函数wait和waitpid\"></a>8.6 函数wait和waitpid</h2><p>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。</p>\n<p>当一个进程调用wait或waitpid可能发生：</p>\n<ul>\n<li>如果所有子进程都还在运行，则阻塞</li>\n<li>如果一个子进程已经终止，等待父进程获取其终止状态，则取得状态返回。</li>\n<li>如果没有任何子进程则立即出差返回</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#inlcude<span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"type\">int</span> *statloc)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">waitpid</span><span class=\"params\">(<span class=\"type\">pid_t</span> pid,<span class=\"type\">int</span> *statloc,<span class=\"type\">int</span> options)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//两个函数返回值：若成功，则返回进程ID；若出错，则返回0或-1</span></span></span><br></pre></td></tr></table></figure>\n\n<p>若statloc不为空，则终止状态便存放在该单元中，可以使用&lt;sys&#x2F;wait.h&gt;中的宏来查看。</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660272991111-28e0a4d0-70b8-47be-9b6d-16398b01776f.png\" alt=\"img\"></p>\n<h4 id=\"8-6-c\"><a href=\"#8-6-c\" class=\"headerlink\" title=\"8.6.c\"></a>8.6.c</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc <span class=\"number\">8.6</span>.c</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">normal termination, exit status = <span class=\"number\">7</span></span><br><span class=\"line\">abnormal termination, signal number = <span class=\"number\">6</span>  (core file generated)</span><br><span class=\"line\">abnormal termination, signal number = <span class=\"number\">8</span>  (core file generated)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对于waitpid中pid参数的解释\"><a href=\"#对于waitpid中pid参数的解释\" class=\"headerlink\" title=\"对于waitpid中pid参数的解释\"></a>对于waitpid中pid参数的解释</h4><ul>\n<li>pid&#x3D;&#x3D;1 等待任一子进程</li>\n<li>pid&gt;0 等待进程ID与pid相等的子进程</li>\n<li>pid&#x3D;&#x3D;0 等待进程组ID等于调用进程组pid的任一子进程</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"8-2-进程标识\"><a href=\"#8-2-进程标识\" class=\"headerlink\" title=\"8.2 进程标识\"></a>8.2 进程标识</h2><p>每个进程都有一个非负整型表示唯一的进程ID。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下列函数返回进程的一些其他标识符</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">getpid</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;\t\t\t<span class=\"comment\">//返回值：调用进程的进程ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">getppid</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;\t\t<span class=\"comment\">//返回值：调用进程的父进程ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">upid_t</span> <span class=\"title\">getpid</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;\t\t<span class=\"comment\">//返回值：调用进程的实际用户ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">gpid_t</span> <span class=\"title\">getpid</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;\t\t<span class=\"comment\">//返回值：调用进程的实际组ID</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-3-函数fork\"><a href=\"#8-3-函数fork\" class=\"headerlink\" title=\"8.3 函数fork\"></a>8.3 函数fork</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个现有的进程可以调用fork函数创建一个新进程</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<p>子进程是父进程的副本，但并不共享存储空间。父进程和子进程共享正文段。</p>\n<p>很多时候子进程并不执行父进程的完全副本，而是使用了写时复制（COW）技术，由父进程与子进程共享数据区域，由内核将他们的权限改变为只读，当需要修改时再复制一份副本。</p>\n<h4 id=\"8-3-c\"><a href=\"#8-3-c\" class=\"headerlink\" title=\"8.3.c\"></a>8.3.c</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc <span class=\"number\">8.3</span>.c -lapue</span><br><span class=\"line\">$ ./a.out </span><br><span class=\"line\">a write to stdout</span><br><span class=\"line\">before fork</span><br><span class=\"line\">pid = <span class=\"number\">11998</span>, glob = <span class=\"number\">7</span>, var = <span class=\"number\">89</span></span><br><span class=\"line\">pid = <span class=\"number\">11997</span>, glob = <span class=\"number\">6</span>, var = <span class=\"number\">88</span></span><br><span class=\"line\">$ ./a.out &gt; temp.out</span><br><span class=\"line\">$ cat temp.out </span><br><span class=\"line\">a write to stdout</span><br><span class=\"line\">before fork</span><br><span class=\"line\">pid = <span class=\"number\">12021</span>, glob = <span class=\"number\">7</span>, var = <span class=\"number\">89</span></span><br><span class=\"line\">before fork</span><br><span class=\"line\">pid = <span class=\"number\">12020</span>, glob = <span class=\"number\">6</span>, var = <span class=\"number\">88</span></span><br></pre></td></tr></table></figure>\n\n<p>当输出到终端时stdout是行缓冲，输出到文件时是全缓冲。</p>\n<p>全缓冲。输入或输出缓冲区被填满，会进行实际 I&#x2F;O 操作。其他情况，如强制刷新、进程结束也会进行实际I&#x2F;O操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">write</span>(STDOUT_FILENO, buf, <span class=\"built_in\">sizeof</span>(buf)) != <span class=\"built_in\">sizeof</span>(buf))</span><br></pre></td></tr></table></figure>\n\n<p>sizeof(buf)-1忽略了buf末尾的null，因此 “a write to stdout\\n” 留在了缓冲区中。</p>\n<p>buf直接写入标准输出，不受缓冲区影响。</p>\n<p>printf(“before fork\\n”)在输出到文件时未flush缓冲区，在fork的过程中复制了缓冲区，因此输出了两次。</p>\n<h4 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h4><p>父进程和子进程每个相同的打开描述符</p>\n<ul>\n<li>共享一个文件表项</li>\n<li>共享同一个文件偏移量</li>\n</ul>\n<p>fork的两个常见用法：</p>\n<ul>\n<li>父进程与子进程执行不同的代码段</li>\n<li>一个进程要执行一个不同的程序（fork后立即调用exec）</li>\n</ul>\n<h2 id=\"8-4-函数vfork\"><a href=\"#8-4-函数vfork\" class=\"headerlink\" title=\"8.4 函数vfork\"></a>8.4 函数vfork</h2><p>vfork用于创造并执行一个新程序。</p>\n<h4 id=\"8-4-c\"><a href=\"#8-4-c\" class=\"headerlink\" title=\"8.4.c\"></a>8.4.c</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc <span class=\"number\">8.4</span>.c</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">before vfork</span><br><span class=\"line\">pid = <span class=\"number\">22413</span>, glob = <span class=\"number\">7</span>, car = <span class=\"number\">89</span></span><br></pre></td></tr></table></figure>\n\n<p>vfork与fork的区别在于：</p>\n<ul>\n<li>vfork 会保证子进程在父进程之前运行，直到子进程触发了 exec 或者 exit 。</li>\n<li>vfork 不会将父进程的地址空间完全复制过来，在子进程调用 exec 或者 exit 之前，它在父进程的空间中运行。</li>\n</ul>\n<h2 id=\"8-5-函数exit\"><a href=\"#8-5-函数exit\" class=\"headerlink\" title=\"8.5 函数exit\"></a>8.5 函数exit</h2><p>如7.3所述，进程有5种正常及3种异常终止方式。</p>\n<p>我们希望终止进程能够通知父进程它是如何终止的，实现这一点的方式是将其退出状态作为参数传递给函数。</p>\n<p>若父进程在子进程之前终止，则子进程会被init进程收养。</p>\n<h2 id=\"8-6-函数wait和waitpid\"><a href=\"#8-6-函数wait和waitpid\" class=\"headerlink\" title=\"8.6 函数wait和waitpid\"></a>8.6 函数wait和waitpid</h2><p>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。</p>\n<p>当一个进程调用wait或waitpid可能发生：</p>\n<ul>\n<li>如果所有子进程都还在运行，则阻塞</li>\n<li>如果一个子进程已经终止，等待父进程获取其终止状态，则取得状态返回。</li>\n<li>如果没有任何子进程则立即出差返回</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#inlcude<span class=\"string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"type\">int</span> *statloc)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">pid_t</span> <span class=\"title\">waitpid</span><span class=\"params\">(<span class=\"type\">pid_t</span> pid,<span class=\"type\">int</span> *statloc,<span class=\"type\">int</span> options)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//两个函数返回值：若成功，则返回进程ID；若出错，则返回0或-1</span></span></span><br></pre></td></tr></table></figure>\n\n<p>若statloc不为空，则终止状态便存放在该单元中，可以使用&lt;sys&#x2F;wait.h&gt;中的宏来查看。</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660272991111-28e0a4d0-70b8-47be-9b6d-16398b01776f.png\" alt=\"img\"></p>\n<h4 id=\"8-6-c\"><a href=\"#8-6-c\" class=\"headerlink\" title=\"8.6.c\"></a>8.6.c</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc <span class=\"number\">8.6</span>.c</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">normal termination, exit status = <span class=\"number\">7</span></span><br><span class=\"line\">abnormal termination, signal number = <span class=\"number\">6</span>  (core file generated)</span><br><span class=\"line\">abnormal termination, signal number = <span class=\"number\">8</span>  (core file generated)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对于waitpid中pid参数的解释\"><a href=\"#对于waitpid中pid参数的解释\" class=\"headerlink\" title=\"对于waitpid中pid参数的解释\"></a>对于waitpid中pid参数的解释</h4><ul>\n<li>pid&#x3D;&#x3D;1 等待任一子进程</li>\n<li>pid&gt;0 等待进程ID与pid相等的子进程</li>\n<li>pid&#x3D;&#x3D;0 等待进程组ID等于调用进程组pid的任一子进程</li>\n</ul>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-07-24T08:51:31.153Z","updated":"2022-07-24T08:51:31.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6qlk73i000e4lz21wfj8nxi","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Unix环境高级编程第三章-文件I/O","date":"2022-08-11T03:11:04.000Z","cover":"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161416.png","_content":"\n## 3.2 文件描述符\n\n- STDIN_FILENO（0）与进程的标准输入关联\n- STDOUT_FILENO（1）与进程的标准输出关联\n- STDERR_FILENO（2）与进程的标准错误关联\n\n在头文件<unistd.h>中定义\n\n## 3.3 函数open和openat\n\n```cpp\n// 调用open或openat函数可以打开或创造一个文件\n\n#include<fcntl.h>\n\nint open(const char *path,int oflag,.../* mode_t mode */;\n         \nint open(const char *path,const char *path,int oflag,.../* mode_t mode */;\n         \n// 两函数的返回值:若成功，返回文件描述符;若出错，返回-1\n```\n\n### path参数：要打开或创造文件的名字\n\n### oflag参数：说明函数的多个选项\n\n- O_RDONLY\t\t只读打开\n- O_WRONLY\t\t只写打开\n- O_DRWR\t\t读、写打开\n- O_EXEC \t\t只执行打开\n- O_SEARCH\t\t只搜索打开\n\n以上参数必须且只能指定一个\n\n\n\n**由open和openat函数返回的文件描述符一定是最小未用描述符数值**\n\n### open与openat的区别\n\nfd参数指出了相对路径名在文件系统中的开始地址\n\n- openat使线程可以使用相对路径名打开目录中的文件\n- 避免TOCTTOU错误\n\n如果有两个基于文件的函数调用，第二个调用依赖第一个调用的结果，因为两个操作不是原子操作，程序是脆弱的。\n\n## 3.4 函数creat\n\n```cpp\n// 也可调用creat函数创建一个新文件。\n\n#include <fentl.h>\n\nint creat (const char *path, mode_ t mode);\n\n// 返回值:若成功，返回为只写打开的文件描述符;若出错，返回-1\n```\n\n## 3.5 函数close\n\n```cpp\n// 可调用close函数关闭一个打开文件\n\n#include <unistd.h>\n\nint close (int fd);\n\n// 返回值:若成功，返回0;若出错，返回-1\n```\n\n## 3.6 函数lseek\n\n```cpp\n// 可以调用lseek显式地为一个打开文件设置偏移量\n\n#include <unistd.h>\n\noff_ t lseek(int fd, off_ t offset， int whence);\n\n// 返回值:若成功，返回新的文件偏移量;若出错，返回-1\n```\n\n\n\n对参数offset的解释与参数whence的值有关:\n\n- 若whence是SEEKSET，则将该文件的偏移量设置为距文件开始处offset个字节。\n- 若whence是SEEK_ CUR， 则将该文件的偏移量设置为其当前值加fset, ofset可为正或负。\n- 若whence是SEEK_ END，则将该文件的偏移量设置为文件长度加offset, offset 可正可负。\n\n\n\n- 0绝对偏移量\n- 1相对偏移量\n- 2相对于尾部偏移量\n\n也可用于确定某文件是否可以设置偏移量，如管道、FIFO或网络套接字。\n\n若不能设置偏移量则返回-1。\n\n### 使用lseek创造一个具有空洞的程序\n\n```cpp\n#include \"apue.h\"\n#include <fcntl.h>\n\nchar\tbuf1[] = \"abcdefghij\";\nchar\tbuf2[] = \"ABCDEFGHIJ\";\n\nint\nmain(void)\n{\n\tint\t\tfd;\n\n\tif ((fd = creat(\"file.hole\", FILE_MODE)) < 0)\n\t\terr_sys(\"creat error\");\n\n\tif (write(fd, buf1, 10) != 10)\n\t\terr_sys(\"buf1 write error\");\n\t/* offset now = 10 */\n\n\tif (lseek(fd, 16384, SEEK_SET) == -1)\n\t\terr_sys(\"lseek error\");\n\t/* offset now = 16384 */\n\n\tif (write(fd, buf2, 10) != 10)\n\t\terr_sys(\"buf2 write error\");\n\t/* offset now = 16394 */\n\n\texit(0);\n}\n```\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660184692174-bd3f1d24-d83a-4b74-9d61-2c57d1f4f100-20220812205545251.png)\n\n## 3.7 函数read\n\n```cpp\n// 调用read函数从打开文件中读数据。\n\n#include <unistd.h>\n\nssize_ t read(int fd, void *buf, size_ t nbytes);\n\n// 返回值:读到的字节数，若已到文件尾，返回0;若出错返回-1 .\n// 如read成功，则返回读到的字节数。如已到达文件的尾端，则返回0\n```\n\n有多种情况使世纪读到的字节数少于要读的字节数：\n\n- 读普通文件时，在读到要求字节数之前已到达文件尾部。下次调用read时返回0.\n- 从终端设备读时。\n- 从网络设备读时，网络的缓冲机制可能造成。\n- 从管道或FIFO读时，管道包含字节少于所需的数量，那么read将返回实际可用的字节数。\n\n## 3.8 函数write\n\n```cpp\n// 调用write函数向打开文件写数据\n\n#include <unistd.h>\n\nssize_ t write(int fd, const void *buf， size_ t nbytes); \n\n// 返回值:若成功，返回已写的字节数:若出错，返回-1\n```\n\n返回值常常与nbytes的值相同。\n\n## 3.9 I/O效率\n\n本节主要讨论缓冲区大小对I/O效率的影响\n\n大多数文件系统采用预读技术，使用较大缓冲区可以提高读写效率，但缓冲区足够大时效率几乎相同。\n\n## 3.10 文件共享\n\n### 内核用于所有I/O的数据结构\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660185557445-39386832-7426-4236-9890-c697df81d0d9-20220812205546562.png)\n\n每个进程都有自己独立的文件表项，这可以使每个进程都有自己对该文件的当前偏移量。\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660185954611-649b880e-fadb-4fb1-8517-7ab30c0cf24a-20220812205547691.png)\n\n## 3.11 原子操作\n\n## 3.12 函数dup和dup2\n\n下面两个函数都可用来复制一个现有的文件描述符:\n\n```cpp\n// 下面两个函数都可用来复制一个现有的文件描述符\n\n#include <unistd.h>\n\nint dup(int fd);\n\nint dup2(int fd, int fd2);\n\n// 两函数的返回值:若成功，返回新的文件描述符:若出错，返回-1\n```\n\n由dup返回的新文件描述符一定是当前可用的最小数值。\n\n对于dup2，若fd2已打开，先关闭fd2；若fd2等于fd，则直接返回fd2.\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660186375474-712798d2-75cc-4732-8d6a-44ff67ba3ea9-20220812205548658.png)\n","source":"_posts/Unix环境高级编程第三章-文件I-O.md","raw":"---\ntitle: Unix环境高级编程第三章-文件I/O\ndate: 2022-08-11 11:11:04\ntags:\n  - Linux\ncategories: Linux学习\ncover: https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811161416.png\n---\n\n## 3.2 文件描述符\n\n- STDIN_FILENO（0）与进程的标准输入关联\n- STDOUT_FILENO（1）与进程的标准输出关联\n- STDERR_FILENO（2）与进程的标准错误关联\n\n在头文件<unistd.h>中定义\n\n## 3.3 函数open和openat\n\n```cpp\n// 调用open或openat函数可以打开或创造一个文件\n\n#include<fcntl.h>\n\nint open(const char *path,int oflag,.../* mode_t mode */;\n         \nint open(const char *path,const char *path,int oflag,.../* mode_t mode */;\n         \n// 两函数的返回值:若成功，返回文件描述符;若出错，返回-1\n```\n\n### path参数：要打开或创造文件的名字\n\n### oflag参数：说明函数的多个选项\n\n- O_RDONLY\t\t只读打开\n- O_WRONLY\t\t只写打开\n- O_DRWR\t\t读、写打开\n- O_EXEC \t\t只执行打开\n- O_SEARCH\t\t只搜索打开\n\n以上参数必须且只能指定一个\n\n\n\n**由open和openat函数返回的文件描述符一定是最小未用描述符数值**\n\n### open与openat的区别\n\nfd参数指出了相对路径名在文件系统中的开始地址\n\n- openat使线程可以使用相对路径名打开目录中的文件\n- 避免TOCTTOU错误\n\n如果有两个基于文件的函数调用，第二个调用依赖第一个调用的结果，因为两个操作不是原子操作，程序是脆弱的。\n\n## 3.4 函数creat\n\n```cpp\n// 也可调用creat函数创建一个新文件。\n\n#include <fentl.h>\n\nint creat (const char *path, mode_ t mode);\n\n// 返回值:若成功，返回为只写打开的文件描述符;若出错，返回-1\n```\n\n## 3.5 函数close\n\n```cpp\n// 可调用close函数关闭一个打开文件\n\n#include <unistd.h>\n\nint close (int fd);\n\n// 返回值:若成功，返回0;若出错，返回-1\n```\n\n## 3.6 函数lseek\n\n```cpp\n// 可以调用lseek显式地为一个打开文件设置偏移量\n\n#include <unistd.h>\n\noff_ t lseek(int fd, off_ t offset， int whence);\n\n// 返回值:若成功，返回新的文件偏移量;若出错，返回-1\n```\n\n\n\n对参数offset的解释与参数whence的值有关:\n\n- 若whence是SEEKSET，则将该文件的偏移量设置为距文件开始处offset个字节。\n- 若whence是SEEK_ CUR， 则将该文件的偏移量设置为其当前值加fset, ofset可为正或负。\n- 若whence是SEEK_ END，则将该文件的偏移量设置为文件长度加offset, offset 可正可负。\n\n\n\n- 0绝对偏移量\n- 1相对偏移量\n- 2相对于尾部偏移量\n\n也可用于确定某文件是否可以设置偏移量，如管道、FIFO或网络套接字。\n\n若不能设置偏移量则返回-1。\n\n### 使用lseek创造一个具有空洞的程序\n\n```cpp\n#include \"apue.h\"\n#include <fcntl.h>\n\nchar\tbuf1[] = \"abcdefghij\";\nchar\tbuf2[] = \"ABCDEFGHIJ\";\n\nint\nmain(void)\n{\n\tint\t\tfd;\n\n\tif ((fd = creat(\"file.hole\", FILE_MODE)) < 0)\n\t\terr_sys(\"creat error\");\n\n\tif (write(fd, buf1, 10) != 10)\n\t\terr_sys(\"buf1 write error\");\n\t/* offset now = 10 */\n\n\tif (lseek(fd, 16384, SEEK_SET) == -1)\n\t\terr_sys(\"lseek error\");\n\t/* offset now = 16384 */\n\n\tif (write(fd, buf2, 10) != 10)\n\t\terr_sys(\"buf2 write error\");\n\t/* offset now = 16394 */\n\n\texit(0);\n}\n```\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660184692174-bd3f1d24-d83a-4b74-9d61-2c57d1f4f100-20220812205545251.png)\n\n## 3.7 函数read\n\n```cpp\n// 调用read函数从打开文件中读数据。\n\n#include <unistd.h>\n\nssize_ t read(int fd, void *buf, size_ t nbytes);\n\n// 返回值:读到的字节数，若已到文件尾，返回0;若出错返回-1 .\n// 如read成功，则返回读到的字节数。如已到达文件的尾端，则返回0\n```\n\n有多种情况使世纪读到的字节数少于要读的字节数：\n\n- 读普通文件时，在读到要求字节数之前已到达文件尾部。下次调用read时返回0.\n- 从终端设备读时。\n- 从网络设备读时，网络的缓冲机制可能造成。\n- 从管道或FIFO读时，管道包含字节少于所需的数量，那么read将返回实际可用的字节数。\n\n## 3.8 函数write\n\n```cpp\n// 调用write函数向打开文件写数据\n\n#include <unistd.h>\n\nssize_ t write(int fd, const void *buf， size_ t nbytes); \n\n// 返回值:若成功，返回已写的字节数:若出错，返回-1\n```\n\n返回值常常与nbytes的值相同。\n\n## 3.9 I/O效率\n\n本节主要讨论缓冲区大小对I/O效率的影响\n\n大多数文件系统采用预读技术，使用较大缓冲区可以提高读写效率，但缓冲区足够大时效率几乎相同。\n\n## 3.10 文件共享\n\n### 内核用于所有I/O的数据结构\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660185557445-39386832-7426-4236-9890-c697df81d0d9-20220812205546562.png)\n\n每个进程都有自己独立的文件表项，这可以使每个进程都有自己对该文件的当前偏移量。\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660185954611-649b880e-fadb-4fb1-8517-7ab30c0cf24a-20220812205547691.png)\n\n## 3.11 原子操作\n\n## 3.12 函数dup和dup2\n\n下面两个函数都可用来复制一个现有的文件描述符:\n\n```cpp\n// 下面两个函数都可用来复制一个现有的文件描述符\n\n#include <unistd.h>\n\nint dup(int fd);\n\nint dup2(int fd, int fd2);\n\n// 两函数的返回值:若成功，返回新的文件描述符:若出错，返回-1\n```\n\n由dup返回的新文件描述符一定是当前可用的最小数值。\n\n对于dup2，若fd2已打开，先关闭fd2；若fd2等于fd，则直接返回fd2.\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660186375474-712798d2-75cc-4732-8d6a-44ff67ba3ea9-20220812205548658.png)\n","slug":"Unix环境高级编程第三章-文件I-O","published":1,"updated":"2022-08-12T12:57:49.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6qlk73i000g4lz26a6892gu","content":"<h2 id=\"3-2-文件描述符\"><a href=\"#3-2-文件描述符\" class=\"headerlink\" title=\"3.2 文件描述符\"></a>3.2 文件描述符</h2><ul>\n<li>STDIN_FILENO（0）与进程的标准输入关联</li>\n<li>STDOUT_FILENO（1）与进程的标准输出关联</li>\n<li>STDERR_FILENO（2）与进程的标准错误关联</li>\n</ul>\n<p>在头文件&lt;unistd.h&gt;中定义</p>\n<h2 id=\"3-3-函数open和openat\"><a href=\"#3-3-函数open和openat\" class=\"headerlink\" title=\"3.3 函数open和openat\"></a>3.3 函数open和openat</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用open或openat函数可以打开或创造一个文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *path,<span class=\"type\">int</span> oflag,...<span class=\"comment\">/* mode_t mode */</span>;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"type\">int</span> open(<span class=\"type\">const</span> <span class=\"type\">char</span> *path,<span class=\"type\">const</span> <span class=\"type\">char</span> *path,<span class=\"type\">int</span> oflag,...<span class=\"comment\">/* mode_t mode */</span>;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"comment\">// 两函数的返回值:若成功，返回文件描述符;若出错，返回-1</span></span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"path参数：要打开或创造文件的名字\"><a href=\"#path参数：要打开或创造文件的名字\" class=\"headerlink\" title=\"path参数：要打开或创造文件的名字\"></a>path参数：要打开或创造文件的名字</h3><h3 id=\"oflag参数：说明函数的多个选项\"><a href=\"#oflag参数：说明函数的多个选项\" class=\"headerlink\" title=\"oflag参数：说明函数的多个选项\"></a>oflag参数：说明函数的多个选项</h3><ul>\n<li>O_RDONLY\t\t只读打开</li>\n<li>O_WRONLY\t\t只写打开</li>\n<li>O_DRWR\t\t读、写打开</li>\n<li>O_EXEC \t\t只执行打开</li>\n<li>O_SEARCH\t\t只搜索打开</li>\n</ul>\n<p>以上参数必须且只能指定一个</p>\n<p><strong>由open和openat函数返回的文件描述符一定是最小未用描述符数值</strong></p>\n<h3 id=\"open与openat的区别\"><a href=\"#open与openat的区别\" class=\"headerlink\" title=\"open与openat的区别\"></a>open与openat的区别</h3><p>fd参数指出了相对路径名在文件系统中的开始地址</p>\n<ul>\n<li>openat使线程可以使用相对路径名打开目录中的文件</li>\n<li>避免TOCTTOU错误</li>\n</ul>\n<p>如果有两个基于文件的函数调用，第二个调用依赖第一个调用的结果，因为两个操作不是原子操作，程序是脆弱的。</p>\n<h2 id=\"3-4-函数creat\"><a href=\"#3-4-函数creat\" class=\"headerlink\" title=\"3.4 函数creat\"></a>3.4 函数creat</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 也可调用creat函数创建一个新文件。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fentl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">creat</span> <span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *path, mode_ t mode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:若成功，返回为只写打开的文件描述符;若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-函数close\"><a href=\"#3-5-函数close\" class=\"headerlink\" title=\"3.5 函数close\"></a>3.5 函数close</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可调用close函数关闭一个打开文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">close</span> <span class=\"params\">(<span class=\"type\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:若成功，返回0;若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-函数lseek\"><a href=\"#3-6-函数lseek\" class=\"headerlink\" title=\"3.6 函数lseek\"></a>3.6 函数lseek</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以调用lseek显式地为一个打开文件设置偏移量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">off_ t <span class=\"title\">lseek</span><span class=\"params\">(<span class=\"type\">int</span> fd, off_ t offset， <span class=\"type\">int</span> whence)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:若成功，返回新的文件偏移量;若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>对参数offset的解释与参数whence的值有关:</p>\n<ul>\n<li><p>若whence是SEEKSET，则将该文件的偏移量设置为距文件开始处offset个字节。</p>\n</li>\n<li><p>若whence是SEEK_ CUR， 则将该文件的偏移量设置为其当前值加fset, ofset可为正或负。</p>\n</li>\n<li><p>若whence是SEEK_ END，则将该文件的偏移量设置为文件长度加offset, offset 可正可负。</p>\n</li>\n<li><p>0绝对偏移量</p>\n</li>\n<li><p>1相对偏移量</p>\n</li>\n<li><p>2相对于尾部偏移量</p>\n</li>\n</ul>\n<p>也可用于确定某文件是否可以设置偏移量，如管道、FIFO或网络套接字。</p>\n<p>若不能设置偏移量则返回-1。</p>\n<h3 id=\"使用lseek创造一个具有空洞的程序\"><a href=\"#使用lseek创造一个具有空洞的程序\" class=\"headerlink\" title=\"使用lseek创造一个具有空洞的程序\"></a>使用lseek创造一个具有空洞的程序</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;apue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span>\tbuf1[] = <span class=\"string\">&quot;abcdefghij&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span>\tbuf2[] = <span class=\"string\">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span>\t\tfd;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((fd = <span class=\"built_in\">creat</span>(<span class=\"string\">&quot;file.hole&quot;</span>, FILE_MODE)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">err_sys</span>(<span class=\"string\">&quot;creat error&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">write</span>(fd, buf1, <span class=\"number\">10</span>) != <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">err_sys</span>(<span class=\"string\">&quot;buf1 write error&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* offset now = 10 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">lseek</span>(fd, <span class=\"number\">16384</span>, SEEK_SET) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">err_sys</span>(<span class=\"string\">&quot;lseek error&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* offset now = 16384 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">write</span>(fd, buf2, <span class=\"number\">10</span>) != <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">err_sys</span>(<span class=\"string\">&quot;buf2 write error&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* offset now = 16394 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660184692174-bd3f1d24-d83a-4b74-9d61-2c57d1f4f100-20220812205545251.png\" alt=\"img\"></p>\n<h2 id=\"3-7-函数read\"><a href=\"#3-7-函数read\" class=\"headerlink\" title=\"3.7 函数read\"></a>3.7 函数read</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用read函数从打开文件中读数据。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ssize_ t <span class=\"title\">read</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">void</span> *buf, size_ t nbytes)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:读到的字节数，若已到文件尾，返回0;若出错返回-1 .</span></span><br><span class=\"line\"><span class=\"comment\">// 如read成功，则返回读到的字节数。如已到达文件的尾端，则返回0</span></span><br></pre></td></tr></table></figure>\n\n<p>有多种情况使世纪读到的字节数少于要读的字节数：</p>\n<ul>\n<li>读普通文件时，在读到要求字节数之前已到达文件尾部。下次调用read时返回0.</li>\n<li>从终端设备读时。</li>\n<li>从网络设备读时，网络的缓冲机制可能造成。</li>\n<li>从管道或FIFO读时，管道包含字节少于所需的数量，那么read将返回实际可用的字节数。</li>\n</ul>\n<h2 id=\"3-8-函数write\"><a href=\"#3-8-函数write\" class=\"headerlink\" title=\"3.8 函数write\"></a>3.8 函数write</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用write函数向打开文件写数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ssize_ t <span class=\"title\">write</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">const</span> <span class=\"type\">void</span> *buf， size_ t nbytes)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:若成功，返回已写的字节数:若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<p>返回值常常与nbytes的值相同。</p>\n<h2 id=\"3-9-I-x2F-O效率\"><a href=\"#3-9-I-x2F-O效率\" class=\"headerlink\" title=\"3.9 I&#x2F;O效率\"></a>3.9 I&#x2F;O效率</h2><p>本节主要讨论缓冲区大小对I&#x2F;O效率的影响</p>\n<p>大多数文件系统采用预读技术，使用较大缓冲区可以提高读写效率，但缓冲区足够大时效率几乎相同。</p>\n<h2 id=\"3-10-文件共享\"><a href=\"#3-10-文件共享\" class=\"headerlink\" title=\"3.10 文件共享\"></a>3.10 文件共享</h2><h3 id=\"内核用于所有I-x2F-O的数据结构\"><a href=\"#内核用于所有I-x2F-O的数据结构\" class=\"headerlink\" title=\"内核用于所有I&#x2F;O的数据结构\"></a>内核用于所有I&#x2F;O的数据结构</h3><p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660185557445-39386832-7426-4236-9890-c697df81d0d9-20220812205546562.png\" alt=\"img\"></p>\n<p>每个进程都有自己独立的文件表项，这可以使每个进程都有自己对该文件的当前偏移量。</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660185954611-649b880e-fadb-4fb1-8517-7ab30c0cf24a-20220812205547691.png\" alt=\"img\"></p>\n<h2 id=\"3-11-原子操作\"><a href=\"#3-11-原子操作\" class=\"headerlink\" title=\"3.11 原子操作\"></a>3.11 原子操作</h2><h2 id=\"3-12-函数dup和dup2\"><a href=\"#3-12-函数dup和dup2\" class=\"headerlink\" title=\"3.12 函数dup和dup2\"></a>3.12 函数dup和dup2</h2><p>下面两个函数都可用来复制一个现有的文件描述符:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面两个函数都可用来复制一个现有的文件描述符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span> fd2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 两函数的返回值:若成功，返回新的文件描述符:若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<p>由dup返回的新文件描述符一定是当前可用的最小数值。</p>\n<p>对于dup2，若fd2已打开，先关闭fd2；若fd2等于fd，则直接返回fd2.</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660186375474-712798d2-75cc-4732-8d6a-44ff67ba3ea9-20220812205548658.png\" alt=\"img\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"3-2-文件描述符\"><a href=\"#3-2-文件描述符\" class=\"headerlink\" title=\"3.2 文件描述符\"></a>3.2 文件描述符</h2><ul>\n<li>STDIN_FILENO（0）与进程的标准输入关联</li>\n<li>STDOUT_FILENO（1）与进程的标准输出关联</li>\n<li>STDERR_FILENO（2）与进程的标准错误关联</li>\n</ul>\n<p>在头文件&lt;unistd.h&gt;中定义</p>\n<h2 id=\"3-3-函数open和openat\"><a href=\"#3-3-函数open和openat\" class=\"headerlink\" title=\"3.3 函数open和openat\"></a>3.3 函数open和openat</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用open或openat函数可以打开或创造一个文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *path,<span class=\"type\">int</span> oflag,...<span class=\"comment\">/* mode_t mode */</span>;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"type\">int</span> open(<span class=\"type\">const</span> <span class=\"type\">char</span> *path,<span class=\"type\">const</span> <span class=\"type\">char</span> *path,<span class=\"type\">int</span> oflag,...<span class=\"comment\">/* mode_t mode */</span>;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"comment\">// 两函数的返回值:若成功，返回文件描述符;若出错，返回-1</span></span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"path参数：要打开或创造文件的名字\"><a href=\"#path参数：要打开或创造文件的名字\" class=\"headerlink\" title=\"path参数：要打开或创造文件的名字\"></a>path参数：要打开或创造文件的名字</h3><h3 id=\"oflag参数：说明函数的多个选项\"><a href=\"#oflag参数：说明函数的多个选项\" class=\"headerlink\" title=\"oflag参数：说明函数的多个选项\"></a>oflag参数：说明函数的多个选项</h3><ul>\n<li>O_RDONLY\t\t只读打开</li>\n<li>O_WRONLY\t\t只写打开</li>\n<li>O_DRWR\t\t读、写打开</li>\n<li>O_EXEC \t\t只执行打开</li>\n<li>O_SEARCH\t\t只搜索打开</li>\n</ul>\n<p>以上参数必须且只能指定一个</p>\n<p><strong>由open和openat函数返回的文件描述符一定是最小未用描述符数值</strong></p>\n<h3 id=\"open与openat的区别\"><a href=\"#open与openat的区别\" class=\"headerlink\" title=\"open与openat的区别\"></a>open与openat的区别</h3><p>fd参数指出了相对路径名在文件系统中的开始地址</p>\n<ul>\n<li>openat使线程可以使用相对路径名打开目录中的文件</li>\n<li>避免TOCTTOU错误</li>\n</ul>\n<p>如果有两个基于文件的函数调用，第二个调用依赖第一个调用的结果，因为两个操作不是原子操作，程序是脆弱的。</p>\n<h2 id=\"3-4-函数creat\"><a href=\"#3-4-函数creat\" class=\"headerlink\" title=\"3.4 函数creat\"></a>3.4 函数creat</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 也可调用creat函数创建一个新文件。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fentl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">creat</span> <span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *path, mode_ t mode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:若成功，返回为只写打开的文件描述符;若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-函数close\"><a href=\"#3-5-函数close\" class=\"headerlink\" title=\"3.5 函数close\"></a>3.5 函数close</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可调用close函数关闭一个打开文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">close</span> <span class=\"params\">(<span class=\"type\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:若成功，返回0;若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-函数lseek\"><a href=\"#3-6-函数lseek\" class=\"headerlink\" title=\"3.6 函数lseek\"></a>3.6 函数lseek</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以调用lseek显式地为一个打开文件设置偏移量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">off_ t <span class=\"title\">lseek</span><span class=\"params\">(<span class=\"type\">int</span> fd, off_ t offset， <span class=\"type\">int</span> whence)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:若成功，返回新的文件偏移量;若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>对参数offset的解释与参数whence的值有关:</p>\n<ul>\n<li><p>若whence是SEEKSET，则将该文件的偏移量设置为距文件开始处offset个字节。</p>\n</li>\n<li><p>若whence是SEEK_ CUR， 则将该文件的偏移量设置为其当前值加fset, ofset可为正或负。</p>\n</li>\n<li><p>若whence是SEEK_ END，则将该文件的偏移量设置为文件长度加offset, offset 可正可负。</p>\n</li>\n<li><p>0绝对偏移量</p>\n</li>\n<li><p>1相对偏移量</p>\n</li>\n<li><p>2相对于尾部偏移量</p>\n</li>\n</ul>\n<p>也可用于确定某文件是否可以设置偏移量，如管道、FIFO或网络套接字。</p>\n<p>若不能设置偏移量则返回-1。</p>\n<h3 id=\"使用lseek创造一个具有空洞的程序\"><a href=\"#使用lseek创造一个具有空洞的程序\" class=\"headerlink\" title=\"使用lseek创造一个具有空洞的程序\"></a>使用lseek创造一个具有空洞的程序</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;apue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span>\tbuf1[] = <span class=\"string\">&quot;abcdefghij&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">char</span>\tbuf2[] = <span class=\"string\">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span>\t\tfd;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((fd = <span class=\"built_in\">creat</span>(<span class=\"string\">&quot;file.hole&quot;</span>, FILE_MODE)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">err_sys</span>(<span class=\"string\">&quot;creat error&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">write</span>(fd, buf1, <span class=\"number\">10</span>) != <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">err_sys</span>(<span class=\"string\">&quot;buf1 write error&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* offset now = 10 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">lseek</span>(fd, <span class=\"number\">16384</span>, SEEK_SET) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">err_sys</span>(<span class=\"string\">&quot;lseek error&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* offset now = 16384 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">write</span>(fd, buf2, <span class=\"number\">10</span>) != <span class=\"number\">10</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">err_sys</span>(<span class=\"string\">&quot;buf2 write error&quot;</span>);</span><br><span class=\"line\">\t<span class=\"comment\">/* offset now = 16394 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660184692174-bd3f1d24-d83a-4b74-9d61-2c57d1f4f100-20220812205545251.png\" alt=\"img\"></p>\n<h2 id=\"3-7-函数read\"><a href=\"#3-7-函数read\" class=\"headerlink\" title=\"3.7 函数read\"></a>3.7 函数read</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用read函数从打开文件中读数据。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ssize_ t <span class=\"title\">read</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">void</span> *buf, size_ t nbytes)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:读到的字节数，若已到文件尾，返回0;若出错返回-1 .</span></span><br><span class=\"line\"><span class=\"comment\">// 如read成功，则返回读到的字节数。如已到达文件的尾端，则返回0</span></span><br></pre></td></tr></table></figure>\n\n<p>有多种情况使世纪读到的字节数少于要读的字节数：</p>\n<ul>\n<li>读普通文件时，在读到要求字节数之前已到达文件尾部。下次调用read时返回0.</li>\n<li>从终端设备读时。</li>\n<li>从网络设备读时，网络的缓冲机制可能造成。</li>\n<li>从管道或FIFO读时，管道包含字节少于所需的数量，那么read将返回实际可用的字节数。</li>\n</ul>\n<h2 id=\"3-8-函数write\"><a href=\"#3-8-函数write\" class=\"headerlink\" title=\"3.8 函数write\"></a>3.8 函数write</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用write函数向打开文件写数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ssize_ t <span class=\"title\">write</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">const</span> <span class=\"type\">void</span> *buf， size_ t nbytes)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回值:若成功，返回已写的字节数:若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<p>返回值常常与nbytes的值相同。</p>\n<h2 id=\"3-9-I-x2F-O效率\"><a href=\"#3-9-I-x2F-O效率\" class=\"headerlink\" title=\"3.9 I&#x2F;O效率\"></a>3.9 I&#x2F;O效率</h2><p>本节主要讨论缓冲区大小对I&#x2F;O效率的影响</p>\n<p>大多数文件系统采用预读技术，使用较大缓冲区可以提高读写效率，但缓冲区足够大时效率几乎相同。</p>\n<h2 id=\"3-10-文件共享\"><a href=\"#3-10-文件共享\" class=\"headerlink\" title=\"3.10 文件共享\"></a>3.10 文件共享</h2><h3 id=\"内核用于所有I-x2F-O的数据结构\"><a href=\"#内核用于所有I-x2F-O的数据结构\" class=\"headerlink\" title=\"内核用于所有I&#x2F;O的数据结构\"></a>内核用于所有I&#x2F;O的数据结构</h3><p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660185557445-39386832-7426-4236-9890-c697df81d0d9-20220812205546562.png\" alt=\"img\"></p>\n<p>每个进程都有自己独立的文件表项，这可以使每个进程都有自己对该文件的当前偏移量。</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660185954611-649b880e-fadb-4fb1-8517-7ab30c0cf24a-20220812205547691.png\" alt=\"img\"></p>\n<h2 id=\"3-11-原子操作\"><a href=\"#3-11-原子操作\" class=\"headerlink\" title=\"3.11 原子操作\"></a>3.11 原子操作</h2><h2 id=\"3-12-函数dup和dup2\"><a href=\"#3-12-函数dup和dup2\" class=\"headerlink\" title=\"3.12 函数dup和dup2\"></a>3.12 函数dup和dup2</h2><p>下面两个函数都可用来复制一个现有的文件描述符:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面两个函数都可用来复制一个现有的文件描述符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">int</span> fd2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 两函数的返回值:若成功，返回新的文件描述符:若出错，返回-1</span></span><br></pre></td></tr></table></figure>\n\n<p>由dup返回的新文件描述符一定是当前可用的最小数值。</p>\n<p>对于dup2，若fd2已打开，先关闭fd2；若fd2等于fd，则直接返回fd2.</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660186375474-712798d2-75cc-4732-8d6a-44ff67ba3ea9-20220812205548658.png\" alt=\"img\"></p>\n"},{"title":"基于Docker的FRP内网穿透部署","date":"2022-08-11T07:24:37.000Z","cover":"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811205446.png","_content":"\n云服务器与本地服务器均为Ubuntu系统\n\n## 一、前言\n\n在新配置好的服务器上查看ip地址为192.168.1.14，直接使用ssh命令连接`ssh wjd@192.168.1.14`输入密码后成功连接。\n\n但192.168.1.14为内网ip，内网也称为局域网，当我的笔记本电脑连接的不是家中的网络时，便不能使用该命令来访问服务器，于是乎我决定使用闲置的云服务器基于docker使用frp实现内网穿透。\n\n## 二、内网、公网与NAT\n\n先简单介绍一下几个基本概念。\n\n- 公网ip：广域网IP是指以公网连接Internet上的非保留地址。\n- 内网ip与NAT：鉴于ipv4数量，运营商将一个区域内的设备连在一起，对外只用一个公网ip标识自己。\n- NAT：私有IP+端口 <——> 公网IP+端口\n\n### 内网穿透原理：\n\n首先我们需要一台拥有公网ip的机器（本文使用腾讯云服务器）\n\n在云服务器上部署frp服务端，在本地服务器上部署frp客户端。\n\n通过frp转发，以云服务器为中继实现内网穿透。\n\n## 三、搭建frp服务\n\n### 3.1 在云服务器与本地服务器安装docker\n\ndocker安装服务方便快捷便于管理。\n\n### 3.2 搭建服务端frps\n\n#### 3.2.1 编辑配置文件\n\n由于要使用端口及配置文件映射，我们提前配置好服务端配置文件\n\n```cpp\nmkdir /etc/frp\ntouch /etc/frp/frps.ini\nvi /etc/frp/frps.ini\n```\n\n配置文件如下\n\n```cpp\n[common]\n# 监听端口\nbind_port = 7000\n# 面板端口\ndashboard_port = 7500\n# 登录面板账号设置\ndashboard_user = admin\ndashboard_pwd = admin@123\n\n# 身份验证\ntoken = 12345678\n```\n\n#### 3.2.2 使用以下命令运行frps\n\n```cpp\ndocker run --restart=always --network host -d -v /opt/docker/frps/frps.ini:/etc/frp/frps.ini --name frps snowdreamtech/frps\n```\n\n--network host: host 网络模式，所有容器端口都对应属主机端口，不存在映射关系。\n\n#### 3.2.3 前往服务器控制台放行对应端口\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660209285979-e9f2011b-7aac-4384-a2e1-488964aa1633.png)\n\n#### 3.2.4 访问web界面\n\n使用http://ip:7500，其中ip为你的服务器ip，使用网页打开。\n\n使用配置文件预设的账号密码登陆。\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660209529676-8b54bca3-ecaf-4eb3-95e3-7160b985d97c.png)\n\n可以看到服务端配置成功等待连接。\n\n### 3.3 搭建客户端frpc\n\n按照同样的方式配置客户端\n\n```cpp\nmkdir /etc/frp\ntouch /etc/frp/frpc.ini\nvi /etc/frp/frpc.ini\n```\n\n配置文件如下\n\n```cpp\n[common]\n# server_addr为FRPS服务器IP地址\nserver_addr = x.x.x.x\n# server_port为服务端监听端口，bind_port\nserver_port = 7000\n# 身份验证\ntoken = 12345678\n\n\n# [ssh] 为服务名称，下方此处设置为，访问frp服务段的2288端口时，等同于通过中转服务器访问127.0.0.1的22端口。\n# type 为连接的类型，此处为tcp\n# local_ip 为中转客户端实际访问的IP \n# local_port 为目标端口\n# remote_port 为远程端口\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 2222\n```\n\n运行frpc\n\n```cpp\ndocker run --restart=always --network host -d -v /opt/docker/frpc/frpc.ini:/etc/frp/frpc.ini --name frpc snowdreamtech/frpc\n```\n\n## 四、使用frp服务\n\n在这里笔者踩了很久的坑，使用ssh连接时输入的用户名应为远程主机的用户名\n\n```cpp\nssh 本地服务器的用户名@你的云服务器ip -p 2222\n# 2222为设置的远程端口\n```\n\n输入密码后连接成功\n\n\n\n\n\n\n\n","source":"_posts/基于Docker的FRP内网穿透部署.md","raw":"---\ntitle: 基于Docker的FRP内网穿透部署\ndate: 2022-08-11 15:24:37\ntags:\n  - Linux\n  - Docker\ncategories: 折腾一台小服务器\ncover: https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/20220811205446.png\n---\n\n云服务器与本地服务器均为Ubuntu系统\n\n## 一、前言\n\n在新配置好的服务器上查看ip地址为192.168.1.14，直接使用ssh命令连接`ssh wjd@192.168.1.14`输入密码后成功连接。\n\n但192.168.1.14为内网ip，内网也称为局域网，当我的笔记本电脑连接的不是家中的网络时，便不能使用该命令来访问服务器，于是乎我决定使用闲置的云服务器基于docker使用frp实现内网穿透。\n\n## 二、内网、公网与NAT\n\n先简单介绍一下几个基本概念。\n\n- 公网ip：广域网IP是指以公网连接Internet上的非保留地址。\n- 内网ip与NAT：鉴于ipv4数量，运营商将一个区域内的设备连在一起，对外只用一个公网ip标识自己。\n- NAT：私有IP+端口 <——> 公网IP+端口\n\n### 内网穿透原理：\n\n首先我们需要一台拥有公网ip的机器（本文使用腾讯云服务器）\n\n在云服务器上部署frp服务端，在本地服务器上部署frp客户端。\n\n通过frp转发，以云服务器为中继实现内网穿透。\n\n## 三、搭建frp服务\n\n### 3.1 在云服务器与本地服务器安装docker\n\ndocker安装服务方便快捷便于管理。\n\n### 3.2 搭建服务端frps\n\n#### 3.2.1 编辑配置文件\n\n由于要使用端口及配置文件映射，我们提前配置好服务端配置文件\n\n```cpp\nmkdir /etc/frp\ntouch /etc/frp/frps.ini\nvi /etc/frp/frps.ini\n```\n\n配置文件如下\n\n```cpp\n[common]\n# 监听端口\nbind_port = 7000\n# 面板端口\ndashboard_port = 7500\n# 登录面板账号设置\ndashboard_user = admin\ndashboard_pwd = admin@123\n\n# 身份验证\ntoken = 12345678\n```\n\n#### 3.2.2 使用以下命令运行frps\n\n```cpp\ndocker run --restart=always --network host -d -v /opt/docker/frps/frps.ini:/etc/frp/frps.ini --name frps snowdreamtech/frps\n```\n\n--network host: host 网络模式，所有容器端口都对应属主机端口，不存在映射关系。\n\n#### 3.2.3 前往服务器控制台放行对应端口\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660209285979-e9f2011b-7aac-4384-a2e1-488964aa1633.png)\n\n#### 3.2.4 访问web界面\n\n使用http://ip:7500，其中ip为你的服务器ip，使用网页打开。\n\n使用配置文件预设的账号密码登陆。\n\n![img](https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660209529676-8b54bca3-ecaf-4eb3-95e3-7160b985d97c.png)\n\n可以看到服务端配置成功等待连接。\n\n### 3.3 搭建客户端frpc\n\n按照同样的方式配置客户端\n\n```cpp\nmkdir /etc/frp\ntouch /etc/frp/frpc.ini\nvi /etc/frp/frpc.ini\n```\n\n配置文件如下\n\n```cpp\n[common]\n# server_addr为FRPS服务器IP地址\nserver_addr = x.x.x.x\n# server_port为服务端监听端口，bind_port\nserver_port = 7000\n# 身份验证\ntoken = 12345678\n\n\n# [ssh] 为服务名称，下方此处设置为，访问frp服务段的2288端口时，等同于通过中转服务器访问127.0.0.1的22端口。\n# type 为连接的类型，此处为tcp\n# local_ip 为中转客户端实际访问的IP \n# local_port 为目标端口\n# remote_port 为远程端口\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 2222\n```\n\n运行frpc\n\n```cpp\ndocker run --restart=always --network host -d -v /opt/docker/frpc/frpc.ini:/etc/frp/frpc.ini --name frpc snowdreamtech/frpc\n```\n\n## 四、使用frp服务\n\n在这里笔者踩了很久的坑，使用ssh连接时输入的用户名应为远程主机的用户名\n\n```cpp\nssh 本地服务器的用户名@你的云服务器ip -p 2222\n# 2222为设置的远程端口\n```\n\n输入密码后连接成功\n\n\n\n\n\n\n\n","slug":"基于Docker的FRP内网穿透部署","published":1,"updated":"2022-08-11T13:14:15.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6qlk73j000i4lz2f2w5edju","content":"<p>云服务器与本地服务器均为Ubuntu系统</p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>在新配置好的服务器上查看ip地址为192.168.1.14，直接使用ssh命令连接<code>ssh wjd@192.168.1.14</code>输入密码后成功连接。</p>\n<p>但192.168.1.14为内网ip，内网也称为局域网，当我的笔记本电脑连接的不是家中的网络时，便不能使用该命令来访问服务器，于是乎我决定使用闲置的云服务器基于docker使用frp实现内网穿透。</p>\n<h2 id=\"二、内网、公网与NAT\"><a href=\"#二、内网、公网与NAT\" class=\"headerlink\" title=\"二、内网、公网与NAT\"></a>二、内网、公网与NAT</h2><p>先简单介绍一下几个基本概念。</p>\n<ul>\n<li>公网ip：广域网IP是指以公网连接Internet上的非保留地址。</li>\n<li>内网ip与NAT：鉴于ipv4数量，运营商将一个区域内的设备连在一起，对外只用一个公网ip标识自己。</li>\n<li>NAT：私有IP+端口 &lt;——&gt; 公网IP+端口</li>\n</ul>\n<h3 id=\"内网穿透原理：\"><a href=\"#内网穿透原理：\" class=\"headerlink\" title=\"内网穿透原理：\"></a>内网穿透原理：</h3><p>首先我们需要一台拥有公网ip的机器（本文使用腾讯云服务器）</p>\n<p>在云服务器上部署frp服务端，在本地服务器上部署frp客户端。</p>\n<p>通过frp转发，以云服务器为中继实现内网穿透。</p>\n<h2 id=\"三、搭建frp服务\"><a href=\"#三、搭建frp服务\" class=\"headerlink\" title=\"三、搭建frp服务\"></a>三、搭建frp服务</h2><h3 id=\"3-1-在云服务器与本地服务器安装docker\"><a href=\"#3-1-在云服务器与本地服务器安装docker\" class=\"headerlink\" title=\"3.1 在云服务器与本地服务器安装docker\"></a>3.1 在云服务器与本地服务器安装docker</h3><p>docker安装服务方便快捷便于管理。</p>\n<h3 id=\"3-2-搭建服务端frps\"><a href=\"#3-2-搭建服务端frps\" class=\"headerlink\" title=\"3.2 搭建服务端frps\"></a>3.2 搭建服务端frps</h3><h4 id=\"3-2-1-编辑配置文件\"><a href=\"#3-2-1-编辑配置文件\" class=\"headerlink\" title=\"3.2.1 编辑配置文件\"></a>3.2.1 编辑配置文件</h4><p>由于要使用端口及配置文件映射，我们提前配置好服务端配置文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /etc/frp</span><br><span class=\"line\">touch /etc/frp/frps.ini</span><br><span class=\"line\">vi /etc/frp/frps.ini</span><br></pre></td></tr></table></figure>\n\n<p>配置文件如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\"># 监听端口</span><br><span class=\"line\">bind_port = <span class=\"number\">7000</span></span><br><span class=\"line\"># 面板端口</span><br><span class=\"line\">dashboard_port = <span class=\"number\">7500</span></span><br><span class=\"line\"># 登录面板账号设置</span><br><span class=\"line\">dashboard_user = admin</span><br><span class=\"line\">dashboard_pwd = admin@<span class=\"number\">123</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 身份验证</span><br><span class=\"line\">token = <span class=\"number\">12345678</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-2-使用以下命令运行frps\"><a href=\"#3-2-2-使用以下命令运行frps\" class=\"headerlink\" title=\"3.2.2 使用以下命令运行frps\"></a>3.2.2 使用以下命令运行frps</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --restart=always --network host -d -v /opt/docker/frps/frps.ini:/etc/frp/frps.ini --name frps snowdreamtech/frps</span><br></pre></td></tr></table></figure>\n\n<p>–network host: host 网络模式，所有容器端口都对应属主机端口，不存在映射关系。</p>\n<h4 id=\"3-2-3-前往服务器控制台放行对应端口\"><a href=\"#3-2-3-前往服务器控制台放行对应端口\" class=\"headerlink\" title=\"3.2.3 前往服务器控制台放行对应端口\"></a>3.2.3 前往服务器控制台放行对应端口</h4><p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660209285979-e9f2011b-7aac-4384-a2e1-488964aa1633.png\" alt=\"img\"></p>\n<h4 id=\"3-2-4-访问web界面\"><a href=\"#3-2-4-访问web界面\" class=\"headerlink\" title=\"3.2.4 访问web界面\"></a>3.2.4 访问web界面</h4><p>使用<a href=\"http://ip:7500，其中ip为你的服务器ip，使用网页打开。\">http://ip:7500，其中ip为你的服务器ip，使用网页打开。</a></p>\n<p>使用配置文件预设的账号密码登陆。</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660209529676-8b54bca3-ecaf-4eb3-95e3-7160b985d97c.png\" alt=\"img\"></p>\n<p>可以看到服务端配置成功等待连接。</p>\n<h3 id=\"3-3-搭建客户端frpc\"><a href=\"#3-3-搭建客户端frpc\" class=\"headerlink\" title=\"3.3 搭建客户端frpc\"></a>3.3 搭建客户端frpc</h3><p>按照同样的方式配置客户端</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /etc/frp</span><br><span class=\"line\">touch /etc/frp/frpc.ini</span><br><span class=\"line\">vi /etc/frp/frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>配置文件如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\"># server_addr为FRPS服务器IP地址</span><br><span class=\"line\">server_addr = x.x.x.x</span><br><span class=\"line\"># server_port为服务端监听端口，bind_port</span><br><span class=\"line\">server_port = <span class=\"number\">7000</span></span><br><span class=\"line\"># 身份验证</span><br><span class=\"line\">token = <span class=\"number\">12345678</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># [ssh] 为服务名称，下方此处设置为，访问frp服务段的<span class=\"number\">2288</span>端口时，等同于通过中转服务器访问<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>的<span class=\"number\">22</span>端口。</span><br><span class=\"line\"><span class=\"meta\"># type 为连接的类型，此处为tcp</span></span><br><span class=\"line\"># local_ip 为中转客户端实际访问的IP </span><br><span class=\"line\"># local_port 为目标端口</span><br><span class=\"line\"># remote_port 为远程端口</span><br><span class=\"line\"></span><br><span class=\"line\">[ssh]</span><br><span class=\"line\">type = tcp</span><br><span class=\"line\">local_ip = <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">local_port = <span class=\"number\">22</span></span><br><span class=\"line\">remote_port = <span class=\"number\">2222</span></span><br></pre></td></tr></table></figure>\n\n<p>运行frpc</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --restart=always --network host -d -v /opt/docker/frpc/frpc.ini:/etc/frp/frpc.ini --name frpc snowdreamtech/frpc</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、使用frp服务\"><a href=\"#四、使用frp服务\" class=\"headerlink\" title=\"四、使用frp服务\"></a>四、使用frp服务</h2><p>在这里笔者踩了很久的坑，使用ssh连接时输入的用户名应为远程主机的用户名</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh 本地服务器的用户名@你的云服务器ip -p <span class=\"number\">2222</span></span><br><span class=\"line\"># <span class=\"number\">2222</span>为设置的远程端口</span><br></pre></td></tr></table></figure>\n\n<p>输入密码后连接成功</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"那些人，那些事","link_list":[{"name":"唐志远の博客","link":"https://tzy1997.com/","avatar":"https://bu.dusays.com/2022/01/14/cd5ffd485f867.jpg","descr":"古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p>云服务器与本地服务器均为Ubuntu系统</p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>在新配置好的服务器上查看ip地址为192.168.1.14，直接使用ssh命令连接<code>ssh wjd@192.168.1.14</code>输入密码后成功连接。</p>\n<p>但192.168.1.14为内网ip，内网也称为局域网，当我的笔记本电脑连接的不是家中的网络时，便不能使用该命令来访问服务器，于是乎我决定使用闲置的云服务器基于docker使用frp实现内网穿透。</p>\n<h2 id=\"二、内网、公网与NAT\"><a href=\"#二、内网、公网与NAT\" class=\"headerlink\" title=\"二、内网、公网与NAT\"></a>二、内网、公网与NAT</h2><p>先简单介绍一下几个基本概念。</p>\n<ul>\n<li>公网ip：广域网IP是指以公网连接Internet上的非保留地址。</li>\n<li>内网ip与NAT：鉴于ipv4数量，运营商将一个区域内的设备连在一起，对外只用一个公网ip标识自己。</li>\n<li>NAT：私有IP+端口 &lt;——&gt; 公网IP+端口</li>\n</ul>\n<h3 id=\"内网穿透原理：\"><a href=\"#内网穿透原理：\" class=\"headerlink\" title=\"内网穿透原理：\"></a>内网穿透原理：</h3><p>首先我们需要一台拥有公网ip的机器（本文使用腾讯云服务器）</p>\n<p>在云服务器上部署frp服务端，在本地服务器上部署frp客户端。</p>\n<p>通过frp转发，以云服务器为中继实现内网穿透。</p>\n<h2 id=\"三、搭建frp服务\"><a href=\"#三、搭建frp服务\" class=\"headerlink\" title=\"三、搭建frp服务\"></a>三、搭建frp服务</h2><h3 id=\"3-1-在云服务器与本地服务器安装docker\"><a href=\"#3-1-在云服务器与本地服务器安装docker\" class=\"headerlink\" title=\"3.1 在云服务器与本地服务器安装docker\"></a>3.1 在云服务器与本地服务器安装docker</h3><p>docker安装服务方便快捷便于管理。</p>\n<h3 id=\"3-2-搭建服务端frps\"><a href=\"#3-2-搭建服务端frps\" class=\"headerlink\" title=\"3.2 搭建服务端frps\"></a>3.2 搭建服务端frps</h3><h4 id=\"3-2-1-编辑配置文件\"><a href=\"#3-2-1-编辑配置文件\" class=\"headerlink\" title=\"3.2.1 编辑配置文件\"></a>3.2.1 编辑配置文件</h4><p>由于要使用端口及配置文件映射，我们提前配置好服务端配置文件</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /etc/frp</span><br><span class=\"line\">touch /etc/frp/frps.ini</span><br><span class=\"line\">vi /etc/frp/frps.ini</span><br></pre></td></tr></table></figure>\n\n<p>配置文件如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\"># 监听端口</span><br><span class=\"line\">bind_port = <span class=\"number\">7000</span></span><br><span class=\"line\"># 面板端口</span><br><span class=\"line\">dashboard_port = <span class=\"number\">7500</span></span><br><span class=\"line\"># 登录面板账号设置</span><br><span class=\"line\">dashboard_user = admin</span><br><span class=\"line\">dashboard_pwd = admin@<span class=\"number\">123</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 身份验证</span><br><span class=\"line\">token = <span class=\"number\">12345678</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-2-使用以下命令运行frps\"><a href=\"#3-2-2-使用以下命令运行frps\" class=\"headerlink\" title=\"3.2.2 使用以下命令运行frps\"></a>3.2.2 使用以下命令运行frps</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --restart=always --network host -d -v /opt/docker/frps/frps.ini:/etc/frp/frps.ini --name frps snowdreamtech/frps</span><br></pre></td></tr></table></figure>\n\n<p>–network host: host 网络模式，所有容器端口都对应属主机端口，不存在映射关系。</p>\n<h4 id=\"3-2-3-前往服务器控制台放行对应端口\"><a href=\"#3-2-3-前往服务器控制台放行对应端口\" class=\"headerlink\" title=\"3.2.3 前往服务器控制台放行对应端口\"></a>3.2.3 前往服务器控制台放行对应端口</h4><p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660209285979-e9f2011b-7aac-4384-a2e1-488964aa1633.png\" alt=\"img\"></p>\n<h4 id=\"3-2-4-访问web界面\"><a href=\"#3-2-4-访问web界面\" class=\"headerlink\" title=\"3.2.4 访问web界面\"></a>3.2.4 访问web界面</h4><p>使用<a href=\"http://ip:7500，其中ip为你的服务器ip，使用网页打开。\">http://ip:7500，其中ip为你的服务器ip，使用网页打开。</a></p>\n<p>使用配置文件预设的账号密码登陆。</p>\n<p><img src=\"https://raw.githubusercontent.com/WuJunDehuda/PicGo/main/1660209529676-8b54bca3-ecaf-4eb3-95e3-7160b985d97c.png\" alt=\"img\"></p>\n<p>可以看到服务端配置成功等待连接。</p>\n<h3 id=\"3-3-搭建客户端frpc\"><a href=\"#3-3-搭建客户端frpc\" class=\"headerlink\" title=\"3.3 搭建客户端frpc\"></a>3.3 搭建客户端frpc</h3><p>按照同样的方式配置客户端</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /etc/frp</span><br><span class=\"line\">touch /etc/frp/frpc.ini</span><br><span class=\"line\">vi /etc/frp/frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>配置文件如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\"># server_addr为FRPS服务器IP地址</span><br><span class=\"line\">server_addr = x.x.x.x</span><br><span class=\"line\"># server_port为服务端监听端口，bind_port</span><br><span class=\"line\">server_port = <span class=\"number\">7000</span></span><br><span class=\"line\"># 身份验证</span><br><span class=\"line\">token = <span class=\"number\">12345678</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># [ssh] 为服务名称，下方此处设置为，访问frp服务段的<span class=\"number\">2288</span>端口时，等同于通过中转服务器访问<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>的<span class=\"number\">22</span>端口。</span><br><span class=\"line\"><span class=\"meta\"># type 为连接的类型，此处为tcp</span></span><br><span class=\"line\"># local_ip 为中转客户端实际访问的IP </span><br><span class=\"line\"># local_port 为目标端口</span><br><span class=\"line\"># remote_port 为远程端口</span><br><span class=\"line\"></span><br><span class=\"line\">[ssh]</span><br><span class=\"line\">type = tcp</span><br><span class=\"line\">local_ip = <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">local_port = <span class=\"number\">22</span></span><br><span class=\"line\">remote_port = <span class=\"number\">2222</span></span><br></pre></td></tr></table></figure>\n\n<p>运行frpc</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --restart=always --network host -d -v /opt/docker/frpc/frpc.ini:/etc/frp/frpc.ini --name frpc snowdreamtech/frpc</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、使用frp服务\"><a href=\"#四、使用frp服务\" class=\"headerlink\" title=\"四、使用frp服务\"></a>四、使用frp服务</h2><p>在这里笔者踩了很久的坑，使用ssh连接时输入的用户名应为远程主机的用户名</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh 本地服务器的用户名@你的云服务器ip -p <span class=\"number\">2222</span></span><br><span class=\"line\"># <span class=\"number\">2222</span>为设置的远程端口</span><br></pre></td></tr></table></figure>\n\n<p>输入密码后连接成功</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl6qlk73900014lz2a7pc6nfo","category_id":"cl6qlk73b00034lz2hofzbbal","_id":"cl6qlk73c00074lz20yh7gc5q"},{"post_id":"cl6qlk73h000c4lz2eecb07kt","category_id":"cl6qlk73b00034lz2hofzbbal","_id":"cl6qlk73j000j4lz27fp900k2"},{"post_id":"cl6qlk73g00084lz2grq27x5k","category_id":"cl6qlk73h000a4lz261l762j6","_id":"cl6qlk73j000l4lz22eqy329d"},{"post_id":"cl6qlk73i000g4lz26a6892gu","category_id":"cl6qlk73b00034lz2hofzbbal","_id":"cl6qlk73k000o4lz2097pb6zv"},{"post_id":"cl6qlk73g00094lz27486h3ij","category_id":"cl6qlk73h000a4lz261l762j6","_id":"cl6qlk73k000q4lz2f65th9s9"},{"post_id":"cl6qlk73j000i4lz2f2w5edju","category_id":"cl6qlk73k000m4lz2h72vbioi","_id":"cl6qlk73k000t4lz27sjgco2p"}],"PostTag":[{"post_id":"cl6qlk73900014lz2a7pc6nfo","tag_id":"cl6qlk73b00044lz2819fac8l","_id":"cl6qlk73c00064lz22dc5cpe9"},{"post_id":"cl6qlk73g00084lz2grq27x5k","tag_id":"cl6qlk73b00044lz2819fac8l","_id":"cl6qlk73h000b4lz2a1jv31dp"},{"post_id":"cl6qlk73h000c4lz2eecb07kt","tag_id":"cl6qlk73b00044lz2819fac8l","_id":"cl6qlk73i000f4lz28sdj237z"},{"post_id":"cl6qlk73i000g4lz26a6892gu","tag_id":"cl6qlk73b00044lz2819fac8l","_id":"cl6qlk73j000k4lz27p2p2xow"},{"post_id":"cl6qlk73g00094lz27486h3ij","tag_id":"cl6qlk73b00044lz2819fac8l","_id":"cl6qlk73k000n4lz20nn1gdan"},{"post_id":"cl6qlk73g00094lz27486h3ij","tag_id":"cl6qlk73i000d4lz2f24ndte9","_id":"cl6qlk73k000p4lz2bsol7rmr"},{"post_id":"cl6qlk73j000i4lz2f2w5edju","tag_id":"cl6qlk73b00044lz2819fac8l","_id":"cl6qlk73k000r4lz297vx3wcb"},{"post_id":"cl6qlk73j000i4lz2f2w5edju","tag_id":"cl6qlk73i000d4lz2f24ndte9","_id":"cl6qlk73k000s4lz2cj1a0hkb"}],"Tag":[{"name":"Linux","_id":"cl6qlk73b00044lz2819fac8l"},{"name":"Docker","_id":"cl6qlk73i000d4lz2f24ndte9"}]}}